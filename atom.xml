<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>yuex (悟道洞穴人)</title><link href="http://yuex.in/" rel="alternate"></link><link href="http://yuex.in/atom.xml" rel="self"></link><id>http://yuex.in/</id><updated>2015-02-01T00:00:00+08:00</updated><entry><title>Vim技巧之Smart Write</title><link href="http://yuex.in/post/2015/02/vim-technique-smart-write.html" rel="alternate"></link><updated>2015-02-01T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2015-02-01:post/2015/02/vim-technique-smart-write.html</id><summary type="html">&lt;p&gt; 上篇讲到 Smart Quit，通过处理 Vim 中的 &lt;code&gt;E37&lt;/code&gt; 异常，让我们可以更畅快地退出 Vim。但这个解法并不完美，例如我们通过 &lt;code&gt;vim&lt;/code&gt; 命令编辑无名文件时，Smart Quit 在退出时会尝试用 &lt;code&gt;w&lt;/code&gt; 进行保存，但由于当前文件没有文件名，所以会遭遇 Vim 中的 &lt;code&gt;E32&lt;/code&gt; 异常 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;E32: No file name&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 在这篇文章里，我提供一个我在用的 &lt;code&gt;SmartWrite()&lt;/code&gt; 函数，来解决 &lt;code&gt;E32&lt;/code&gt;。闲言少叙，我们还是直接上代码 &lt;/p&gt;
&lt;p&gt; 首先，我们先将 &lt;code&gt;SmartWrite()&lt;/code&gt; 的调用绑定到一个键位，这里暂时用 &lt;code&gt;wq&lt;/code&gt; 替代好了。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;unique&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;wq&lt;/span&gt; :&lt;span class="k"&gt;call&lt;/span&gt; SmartWrite&lt;span class="p"&gt;()&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 一个更好的方法是将 &lt;code&gt;;&lt;/code&gt; 映射为 &lt;code&gt;&amp;lt;Leader&amp;gt;&lt;/code&gt; 键，然后用 &lt;code&gt;&amp;lt;Leader&amp;gt;w&lt;/code&gt; 来调用 &lt;code&gt;SmartWrite()&lt;/code&gt;，这个键位按起来很方便而且很好记。当然，如果插件较多，按键不够用，我们还可以开启 &lt;code&gt;&amp;lt;Alt&amp;gt;&lt;/code&gt; 键来使用更多的组合键。不过这些都不打紧，因为在文章的最后，我们会把 &lt;code&gt;SmartWrite()&lt;/code&gt; 的调用整合进 &lt;code&gt;SmartQuit()&lt;/code&gt; 中，这样就只要记忆一个 &lt;code&gt;&amp;lt;C-c&amp;gt;&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt; 接下来，是 &lt;code&gt;SmartWrite()&lt;/code&gt; 的代码 &lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;function&lt;/span&gt; SmartWrite&lt;span class="p"&gt;(&lt;/span&gt;...&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;a&lt;/span&gt;:&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;a&lt;/span&gt;:&lt;span class="m"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;endif&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; empty&lt;span class="p"&gt;(&lt;/span&gt;bufname&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;call&lt;/span&gt; WriteWithName&lt;span class="p"&gt;(&lt;/span&gt;cmd&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        exec cmd
    &lt;span class="k"&gt;endif&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt; WriteWithName&lt;span class="p"&gt;(&lt;/span&gt;cmd&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;call&lt;/span&gt; inputsave&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;filename&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; input&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;:&amp;#39;&lt;/span&gt;.&lt;span class="k"&gt;a&lt;/span&gt;:cmd.&lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;let&lt;/span&gt; cmds &lt;span class="p"&gt;=&lt;/span&gt; [&lt;span class="k"&gt;a&lt;/span&gt;:cmd&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;filename&lt;/span&gt;]
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt;empty&lt;span class="p"&gt;(&lt;/span&gt;glob&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;redraw&lt;/span&gt;
        echohl WarningMsg
        echo &lt;span class="s1"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;.&lt;span class="k"&gt;filename&lt;/span&gt;.&lt;span class="s1"&gt;&amp;#39;&amp;quot; existed. Force &amp;#39;&lt;/span&gt;.&lt;span class="k"&gt;a&lt;/span&gt;:cmd.&lt;span class="s1"&gt;&amp;#39; [!] ? [Y/n] &amp;#39;&lt;/span&gt;
        echohl None

        &lt;span class="k"&gt;let&lt;/span&gt; choice &lt;span class="p"&gt;=&lt;/span&gt; nr2char&lt;span class="p"&gt;(&lt;/span&gt;getchar&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; choice &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;CR&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; choice &lt;span class="p"&gt;==&lt;/span&gt;? &lt;span class="s1"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;
            &lt;span class="k"&gt;call&lt;/span&gt; CmdExecute&lt;span class="p"&gt;(&lt;/span&gt;cmds&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;endif&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;call&lt;/span&gt; CmdExecute&lt;span class="p"&gt;(&lt;/span&gt;cmds&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;endif&lt;/span&gt;

    &lt;span class="k"&gt;call&lt;/span&gt; inputrestore&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt; CmdExecute&lt;span class="p"&gt;(&lt;/span&gt;cmds&lt;span class="p"&gt;,&lt;/span&gt; force&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;a&lt;/span&gt;:force
        &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;a&lt;/span&gt;:cmds[&lt;span class="m"&gt;0&lt;/span&gt;].&lt;span class="s1"&gt;&amp;#39;! &amp;#39;&lt;/span&gt;.&lt;span class="k"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;a&lt;/span&gt;:cmds[&lt;span class="m"&gt;1&lt;/span&gt;:]&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;a&lt;/span&gt;:cmds&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;endif&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; exists&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;cmd&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        exec cmd
    &lt;span class="k"&gt;endif&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 好在 Vimscript 并不严格要求函数定义与使用的先后顺序，因为是脚本语言嘛，所以这里就按照逻辑上最自然的先后顺序给出代码了。在 &lt;code&gt;SmartWrite()&lt;/code&gt; 中，我们进行一个判断，看当前文件是否有名字。如果有名字，就直接执行默认为写的命令；如果没有名字，就调用 &lt;code&gt;WriteWithName()&lt;/code&gt;。这个函数会要求输入一个文件名字，然后会检查是否存在同名的文件。如果存在，会提示是否强制写，默认是只有 &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 或者 &lt;code&gt;Y&lt;/code&gt; 起头的输入，才会进行强制写入。决定之后，会调用 &lt;code&gt;CmdExecute()&lt;/code&gt; 来真正执行写入的命令。&lt;/p&gt;
&lt;p&gt; 最后，只要在 &lt;code&gt;SmartQuit()&lt;/code&gt; 里进行一下小的调整，就可以将 &lt;code&gt;SmartWrite()&lt;/code&gt; 整合进去了。我们赘述如下，注意其中的 &lt;code&gt;&amp;lt;C-w&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;C-s&amp;gt;&lt;/code&gt; 键的设置，其实是配置了 &lt;strong&gt; 保存 &lt;/strong&gt; 和 &lt;strong&gt; 保存退出 &lt;/strong&gt; 两个键位。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;function&lt;/span&gt; SmartQuit&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt;&amp;amp;&lt;span class="nb"&gt;modified&lt;/span&gt;
        exec &lt;span class="s2"&gt;&amp;quot;quit&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;redraw&lt;/span&gt;
        echohl WarningMsg
        echo &lt;span class="s2"&gt;&amp;quot;Buffer changed! [^W]w [^S]x [^B^N]q!: &amp;quot;&lt;/span&gt;
        echohl None

        &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; nr2char&lt;span class="p"&gt;(&lt;/span&gt;getchar&lt;span class="p"&gt;())&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;C-b&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;C-n&amp;gt;&amp;quot;&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;q!&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;elseif&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;C-w&amp;gt;&amp;quot;&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;call SmartWrite(&amp;#39;w&amp;#39;)&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;elseif&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;C-s&amp;gt;&amp;quot;&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;call SmartWrite(&amp;#39;x&amp;#39;)&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;endif&lt;/span&gt;

        &lt;span class="k"&gt;redraw&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt;empty&lt;span class="p"&gt;(&lt;/span&gt;cmd&lt;span class="p"&gt;)&lt;/span&gt;
            exec cmd
        &lt;span class="k"&gt;endif&lt;/span&gt;
    &lt;span class="k"&gt;endif&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 最后的最后，别忘了我们的 &lt;code&gt;&amp;lt;C-c&amp;gt;&lt;/code&gt; 键映射 &lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;unique&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; :&lt;span class="k"&gt;call&lt;/span&gt; SmartQuit&lt;span class="p"&gt;()&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 以上。&lt;/p&gt;</summary><category term="vim"></category></entry><entry><title>Vim技巧之Smart Quit</title><link href="http://yuex.in/post/2015/01/vim-technique-smart-quit.html" rel="alternate"></link><updated>2015-01-25T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2015-01-25:post/2015/01/vim-technique-smart-quit.html</id><summary type="html">&lt;p&gt; 初学 Vim 时，我们都有这样的经历 ——“ 哇，怎么退出？！”。在尝试了 &lt;code&gt;&amp;lt;Ctrl-C&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; 全都没有效果时，才会注意左下角状态栏的小提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Type  :quit&amp;lt;Enter&amp;gt;  to exit Vim&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 在小心翼翼地键入这个命令完成退出之后，我们欣喜地自认为已经掌握了 Vim 的退出之法。然而，当我们在 Vim 中进行了一番探索、受了一些嘲弄、做了一些不听使唤的修改后，虔诚地键入 &lt;code&gt;:quit&lt;/code&gt;，准备结束这次不成功的尝试，舒缓一下心神，重新来过之时，Vim 又会无情地用一行血红色的小字警告你：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;E37: No write since last change (add ! to override)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 很多人的 Vim 之旅就此便戛然而止。许多年之后，那些并未放弃的人们，早已掌握了 Vim 中的大多数奥妙，但时不时地，仍然会在完成一些快速修改，准备退出进行一下验证或者修改下一个文件的时候，遭遇 Vim 的 &lt;code&gt;E37&lt;/code&gt; 嘲弄。Vim 仿佛是在用这种方式训斥你 ——“ 你，图样图森破，上台拿衣服 ”。虽然，无数次地，我们在论坛上、bbs 里，义正言辞地强调 “WYSIWYG，图样图森破；Vim，时尚时尚最时尚 ”，然而在夜深人静的时候，我们扪心自问，深深明白，Vim 还有很多地方不够完美 &lt;sup id="fnref:!neovim"&gt;&lt;a class="footnote-ref" href="#fn:!neovim" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt; 所以，在这篇文章里，我要展示一个我在用的 Vim 配置，可以让我们在退出的时候，不再遭受 &lt;code&gt;E37&lt;/code&gt; 的痛苦折磨。闲言少叙，直接上相关代码。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;function&lt;/span&gt; SmartQuit&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt;&amp;amp;&lt;span class="nb"&gt;modified&lt;/span&gt;
        exec &lt;span class="s2"&gt;&amp;quot;quit&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;redraw&lt;/span&gt;
        echohl WarningMsg
        echo &lt;span class="s2"&gt;&amp;quot;Buffer changed! [^W]w [^S]x [^B^N]q!: &amp;quot;&lt;/span&gt;
        echohl None

        &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; nr2char&lt;span class="p"&gt;(&lt;/span&gt;getchar&lt;span class="p"&gt;())&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;C-b&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;C-n&amp;gt;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;            &amp;quot; BOOM! NUKE!&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;q!&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;elseif&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;C-w&amp;gt;&amp;quot;&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;w&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;elseif&lt;/span&gt; &lt;span class="k"&gt;ret&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\&amp;lt;C-s&amp;gt;&amp;quot;&lt;/span&gt;
            &lt;span class="k"&gt;let&lt;/span&gt; cmd &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;x&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;endif&lt;/span&gt;

        &lt;span class="k"&gt;redraw&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt;empty&lt;span class="p"&gt;(&lt;/span&gt;cmd&lt;span class="p"&gt;)&lt;/span&gt;
            exec cmd
        &lt;span class="k"&gt;endif&lt;/span&gt;
    &lt;span class="k"&gt;endif&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;unique&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; :&lt;span class="k"&gt;call&lt;/span&gt; SmartQuit&lt;span class="p"&gt;()&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 这段代码很简单，我们将 &lt;code&gt;&amp;lt;C-c&amp;gt;&lt;/code&gt; 映射到调用 &lt;code&gt;SmartQuit()&lt;/code&gt; 函数。而这个函数会检查当前文件是否已经修改过。若没有修改，则直接退出；若有修改，则会提示你进行保存（&lt;code&gt;&amp;lt;C-w&amp;gt;&lt;/code&gt;）、保存退出（&lt;code&gt;&amp;lt;C-s&amp;gt;&lt;/code&gt;）、强制退出（&lt;code&gt;&amp;lt;C-b&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;）、或者取消操作（&lt;code&gt;&amp;lt;C-c&amp;gt;&lt;/code&gt;）。最后根据选择执行相应的命令。&lt;/p&gt;
&lt;p&gt; 当然，如果你不喜欢这几个按键，或者不喜欢那个提示语，可以自行修改以适合自己口味。另外，这个函数在编写的过程中参考了 Stackoverflow 上的一个 &lt;a href="http://stackoverflow.com/a/20075923/2787160"&gt; 回答 &lt;/a&gt;，你也可以进行一下对比，选取合适的部分，再加以发挥形成自己的 SmartQuit。&lt;/p&gt;
&lt;p&gt; 眼尖的读者可能已经发现了，这个配置是要用 &lt;code&gt;&amp;lt;C-c&amp;gt;&lt;/code&gt; 来进行退出 Vim。其实我们也可以用这个按键代替 &lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt;&lt;sup id="fnref:!esc"&gt;&lt;a class="footnote-ref" href="#fn:!esc" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; 来退出 Vim 中的各个模式。这在 Vim 中是一个默认设置，大多数情况下两者的行为是一致的。但有一个例外，就是用 &lt;code&gt;&amp;lt;C-v&amp;gt;&lt;/code&gt; 和 &lt;code&gt;I&lt;/code&gt; 进行多行首插入时。&lt;code&gt;:h i_ctrl-c&lt;/code&gt; 中写明 &lt;code&gt;&amp;lt;C-c&amp;gt;&lt;/code&gt; 在 insert 模式中不会触发 &lt;code&gt;InsertLeave&lt;/code&gt; 事件，因此也就无法完成多行插入了。解决这个问题，也很简单，只要加入如下配置就好了。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nb"&gt;inoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;unique&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Esc&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 另外，以 MacBook Pro 为代表的新一代的笔电设计，愈发地将 &lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; 缩小，并置于偏离键盘左上角的位置，对于 Vim 的使用造成了一定的不便，所以非常推荐大家用 &lt;code&gt;&amp;lt;C-c&amp;gt;&lt;/code&gt; 代替 &lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt;。当然，&lt;strong&gt; 前提是要将 &lt;code&gt;&amp;lt;CapsLock&amp;gt;&lt;/code&gt; 设置为 &lt;code&gt;&amp;lt;Ctrl&amp;gt;&lt;/code&gt;&lt;/strong&gt;。否则，频繁使用 &lt;code&gt;&amp;lt;C-c&amp;gt;&lt;/code&gt; 可能还会更痛苦。不过说到底，这个设置的好与不好，要不要采纳，大家还是要在使用中，根据自己的习惯做出适合自己的选择。&lt;/p&gt;
&lt;p&gt; 以上。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:!neovim"&gt;
&lt;p&gt; 目前针对 Vim 有一个名为 &lt;a href="https://github.com/neovim/neovim"&gt;Neovim&lt;/a&gt; 的改良项目。&amp;#160;&lt;a class="footnote-backref" href="#fnref:!neovim" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:!esc"&gt;
&lt;p&gt;&lt;code&gt;:h esc&lt;/code&gt;，Vim 文档中对 &lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; 的用途进行了详细的描述。&amp;#160;&lt;a class="footnote-backref" href="#fnref:!esc" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="vim"></category></entry><entry><title>Exclusive Queue的一个推广</title><link href="http://yuex.in/post/2015/01/little-book-exclusive-queue-generalization.html" rel="alternate"></link><updated>2015-01-18T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2015-01-18:post/2015/01/little-book-exclusive-queue-generalization.html</id><summary type="html">&lt;p&gt; 最近断断续续地在看一本非常棒的书，Allen B. Downey 的 &lt;a href="http://greenteapress.com/semaphores/"&gt;The Little Book of Semaphores&lt;/a&gt;，理清了许多以前了解得不很确实的知识。&lt;/p&gt;
&lt;p&gt; 这两天看到的书中 3.7 节的 Exclusive Queue。书中介绍了一个可以 1:1 并发向前的队列。一个很自然的想法是如何将其推广到 n:m 的情形。但非常奇怪的是书中并没有像前几节中推广二人约定 Rendezvous&lt;sup id="fnref:!rendezvous"&gt;&lt;a class="footnote-ref" href="#fn:!rendezvous" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;，使之成为多人约定 Barrier 那样，将 1:1 的 Exclusive Queue 推广到 n:m。所以我在这篇拙文中斗胆狗尾续貂，补上这个推广 &lt;sup id="fnref:!note"&gt;&lt;a class="footnote-ref" href="#fn:!note" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt; 首先，和书中之前的定义一样，n:m 情形下，要求有且仅有 n 个 leader 和 m 个 follower 同时进行 dance()。变量定义如下 &lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;leaders&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;proceed&lt;/span&gt;
&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;followers&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;proceed&lt;/span&gt;
&lt;span class="n"&gt;leader&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;follower&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="c"&gt;# 用于记录已经到达的 leader 与 follower 个数 &lt;/span&gt;
&lt;span class="n"&gt;countL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;countF&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;     &lt;span class="c"&gt;# 用于记录正在进行 dance() 的 leader 与 follower 个数 &lt;/span&gt;
&lt;span class="n"&gt;mutex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Semaphore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;# 用于控制 leader 和 follower 的访问 &lt;/span&gt;
&lt;span class="n"&gt;mutexCountL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Semaphore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 用于控制 countL 的访问 &lt;/span&gt;
&lt;span class="n"&gt;mutexCountF&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Semaphore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 用于控制 countF 的访问 &lt;/span&gt;
&lt;span class="n"&gt;leaderQ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Semaphore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 用于 fire leader queue&lt;/span&gt;
&lt;span class="n"&gt;followerQ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Semaphore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;# 用于 fire follower queue&lt;/span&gt;
&lt;span class="n"&gt;rendezvous&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Semaphore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c"&gt;# 用于控制 leader 和 follower 的同步约定 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 以下给出推广问题解的 leader 的代码：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;follower&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;leader&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;follower&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
    &lt;span class="n"&gt;leader&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;followerQ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;leaderQ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;leader&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;leaderQ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;rendezvous&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;mutexCountL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;countL&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;countL&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;countL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;mutexCountL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;singal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 以下给出推广问题解的 follower 的代码：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;leader&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;follower&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;leader&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
    &lt;span class="n"&gt;follower&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;leaderQ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;followerQ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;follower&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;followerQ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;dance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;mutexCountF&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;countF&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;countF&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;countF&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;rendezvous&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;mutexCountF&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;singal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 代码，以上。&lt;/p&gt;
&lt;p&gt; 不过请注意，这里的 n 个 leader 只有在 m 个 follower 全部完成 dance() 之后，才能开始进行第一个 dance()。在 &lt;code&gt;n == m&lt;/code&gt; 的情况下，或者更广泛一点讲，只要 n 和 m 互为整倍数关系时，可以有一个改进，使得固定的一个或几个 follower 完成 dance() 之后，就 fire 成比例的 rendezvous 给 leader。这样 follower 和 leader 就可以一定程度上的并发行进了。&lt;/p&gt;
&lt;p&gt; 拙文，以上。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:!rendezvous"&gt;
&lt;p&gt;rendezvous 的词源是 render (to present) + vous (you)，引申为约会、约会地、集会地。具体可以参考 &lt;a href="http://www.etymonline.com/index.php?term=rendezvous"&gt;etymonline&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:!rendezvous" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:!note"&gt;
&lt;p&gt; 书还没有看完，我怀疑书后面的章节中可能会有问题涉及到这个推广，所以在书的前面也就没有提及。倘若真是这种情况，之后再补上相关的说明。&amp;#160;&lt;a class="footnote-backref" href="#fnref:!note" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="system"></category><category term="semaphore"></category></entry><entry><title>How Linux Work笔记</title><link href="http://yuex.in/post/2015/01/how-linux-work-review.html" rel="alternate"></link><updated>2015-01-11T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2015-01-11:post/2015/01/how-linux-work-review.html</id><summary type="html">&lt;p&gt; 最近看了一本 Linux 方面的 2014 年新书，是 &lt;a href="http://book.douban.com/subject/26266751/"&gt;How Linux Work&lt;/a&gt; 第二版。一开始看名字，以为是 Linux 内核方面相关的，或者是讲如何自制 Linux 发行版的。但最后发现其实就是讲怎么使用 Linux 的。而且这本书也很特别，从内容上来讲，既不是完全给新手看的，也不是完全给老手看，很是别扭。但好在这本书讲到的所有东西都不是很艰深，很多都是信息性的内容，快速过一遍也只要两三个小时。国内人民邮电已经引入了 &lt;a href="http://www.ituring.com.cn/book/1548"&gt; 中文版 &lt;/a&gt;，今年年底前应该可以和大家见面。&lt;/p&gt;
&lt;p&gt; 但诚如至圣先师孔子所言：三人行必有我师。这本书还是让我收获了很多。以下撷取其中的一些内容，与大家分享。&lt;/p&gt;
&lt;p&gt; 使用 mktemp 生成临时文件。只要在 shell 脚本中使用 &lt;code&gt;TEMPFILE=$(mktemp)&lt;/code&gt; 就会在 &lt;code&gt;/tmp&lt;/code&gt; 中生成一个临时文件，然后可以通过访问 &lt;code&gt;${TEMPFILE}&lt;/code&gt; 进行使用，非常方便。&lt;/p&gt;
&lt;p&gt;Shell 脚本的劣势，有以下三点，结合以前的开发经验，还真是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 算术计算，特别是浮点运算，基本不可以原生地做；&lt;/li&gt;
&lt;li&gt; 字符串处理 ; &lt;/li&gt;
&lt;li&gt; 数据库操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 利用 python 速起 http 服务：&lt;code&gt;python -m SimpleHTTPServer&lt;/code&gt;。以后给别人传东西就可以不用 U 盘了。&lt;/p&gt;
&lt;p&gt;rsync 中 &lt;code&gt;/&lt;/code&gt; 的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rsync -a dir/ dest_dir&lt;/code&gt; 会把 dir 下所有内容拷贝到 dest_dir/ 下 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsync -a dir  dest_dir&lt;/code&gt; 会把 dir 下所有内容拷贝到 dest_dir/dir/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;X Window 的替代项目。众所周知，X Window 到现在，时间已经比较长了，不可避免地会有很多历史的包袱，对于平板和智能手机这类的新环境的适应也不会那么灵活，所以有几个新项目出现，以 freedesktop 领衔的 &lt;a href="https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)"&gt;Wayland&lt;/a&gt; 和 Canonical 领衔的 &lt;a href="https://en.wikipedia.org/wiki/Mir_(software)"&gt;Mir&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;D-Bus 是 Desktop-Bus 的缩写，是一个消息传递系统，在桌面应用之间提供一个进程间通信机制，由 Red Hat 牵头开发。&lt;/p&gt;
&lt;p&gt; 另有一个技巧，可以把 vim 用作二进制编辑器。如下 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 以 &lt;code&gt;vim -b file&lt;/code&gt; 打开文件 &lt;/li&gt;
&lt;li&gt; 执行 &lt;code&gt;:%!xxd&lt;/code&gt; 将 ascii 转换为 hex 显示 &lt;/li&gt;
&lt;li&gt; 在 hex 下进行修改 &lt;/li&gt;
&lt;li&gt; 执行 &lt;code&gt;:%!xxd -r&lt;/code&gt; 将 hex 转换回 ascii&lt;/li&gt;
&lt;li&gt; 保存退出 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 以上。&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>使用bash渲染模板动态生成配置文件</title><link href="http://yuex.in/post/2014/10/bash-template.html" rel="alternate"></link><updated>2014-10-14T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2014-10-14:post/2014/10/bash-template.html</id><summary type="html">&lt;p&gt; 在使用 bash 自动化一些配置过程的时候，经常会遇到这样一种情况，我们需要向配置文件中写入一些信息，而这些信息是动态的，只有脚本实际运行的时候，才能知道这些信息。比如我需要自动启动一个由多个 docker container 组成的 cluster。这个 cluster 中的多个 container 形成一个 C/S 架构的星形拓扑。为了可以正常通信，client 至少应该知道 server 的 ip 地址。为了使这个部署可以更灵活，一般会选择使用 dhcp 来动态获取地址。所以，我们不能事先把地址写死，必须在 server container 运行之后动态生成 client 的配置文件。当然，我们也可以把脚本写成两步，先起 server，再起 client。但是这种方法自动化的不彻底，没有一下就把所有工作从头做到尾来得爽快，所以这里也就按下不表了。&lt;/p&gt;
&lt;p&gt; 上面说的这个情况，最直接的方法是用 &lt;code&gt;sed&lt;/code&gt; 配合正则表达一处一处地修改。但是当要修改的地方很多时，这个方法会变得非常繁琐，后期维护也非常困难。我在这里提供一种利用 bash 渲染模板文件动态生成实际使用配置文件的方法。如果你有玩过 jinja2 这种模板语言，这里我要讲的方法和用 jinja2 渲染 template 生成 html 的思路是类似的。&lt;/p&gt;
&lt;p&gt; 闲言少敘，以下是我要讲的方法的代码片段。其中 &lt;code&gt;${template}&lt;/code&gt; 为模板文件的存放路径，而 &lt;code&gt;${dst}&lt;/code&gt; 为生成的配置的文件所欲保存的路径 &lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;cat &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;template&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; |
awk &lt;span class="s1"&gt;&amp;#39;$0 !~ /^\s*#.*$/&amp;#39;&lt;/span&gt; |
sed &lt;span class="s1"&gt;&amp;#39;s/[ &amp;quot;]/\\&amp;amp;/g&amp;#39;&lt;/span&gt; |
&lt;span class="k"&gt;while &lt;/span&gt;&lt;span class="nb"&gt;read&lt;/span&gt; -r line;do
    &lt;span class="nb"&gt;eval echo&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt; &amp;gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;dst&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 以上代码中，&lt;code&gt;awk '$0 !~ /^\s*#.*$/'&lt;/code&gt; 将 &lt;code&gt;cat&lt;/code&gt; 所打印的注释行全部吃掉。&lt;code&gt;sed 's/[ "]/\\&amp;amp;/g'&lt;/code&gt; 将模板文件中的双引号和空格全部转义，用于抵消 &lt;code&gt;eval&lt;/code&gt;。因为我的模板文件中只有这两个 magic character，所以没有处理多余的字符。如果你的模板文件中还使用了其它 magic character，如单引号、圆括弧等，可以根据实际情况修改这一句。&lt;code&gt;while&lt;/code&gt; 循环逐行读入 p 之前管道的输出，&lt;code&gt;-r&lt;/code&gt; 参数保证我们在 &lt;code&gt;sed&lt;/code&gt; 中的转义不会被 &lt;code&gt;read&lt;/code&gt; 吃掉。&lt;code&gt;eval&lt;/code&gt; 将模板中定义的 bash variable 替换为脚本运行时环境中的变量值。最后，将全部结果写入到所欲存储的路径。&lt;/p&gt;
&lt;p&gt; 以下是我所用的模板中的一个片段（yaml 格式的 storm 配置文件）。&lt;code&gt;${ZK_IP}&lt;/code&gt; 是所需要的一个 zookeeper 实例的 ip 地址，需要在 zookeeper container 运行起来之后才能确定。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="l-Scalar-Plain"&gt;storm.zookeeper.servers&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt;
    &lt;span class="p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${ZK_IP}&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 经由上面的代码在运行时渲染后，&lt;code&gt;${ZK_IP}&lt;/code&gt; 会被替换为一个 ipv4 地址，所以实际生成的配置文件可能是这个样子的 &lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="l-Scalar-Plain"&gt;storm.zookeeper.servers&lt;/span&gt;&lt;span class="p-Indicator"&gt;:&lt;/span&gt;
    &lt;span class="p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;172.16.0.1&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt; 这个就是实际的 storm 实例中会使用的配置文件。&lt;/p&gt;
&lt;p&gt; 以上 :)&lt;/p&gt;</summary><category term="bash"></category></entry><entry><title>Arch Linux上手指南</title><link href="http://yuex.in/post/2014/04/arch-guide.html" rel="alternate"></link><updated>2014-04-18T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2014-04-18:post/2014/04/arch-guide.html</id><summary type="html">&lt;h1 id="_1"&gt; 缘起 &lt;/h1&gt;
&lt;p&gt; 一直都想写一篇关于 Arch Linux 的博客，可以用来帮助 Arch 新玩家上路，
又可以总结一下自己入坑三四年来的一些心得。
年前的时候，我的 Thinkpad X220 双硬盘中的 mSATA SSD 挂了，援救了一下数据和系统。
本打算借机写写 Arch Linux 的安装，也积累了一些素材。但思来想去，
每个人的硬件型号、网络环境、分区习惯、软件选择的品味等等，不尽相同，
一份安装指南不一定会对每个人都有用，甚至还有可能在某些情况下起到截然相反的效果，
影响观者对于 Arch 的热情，所以最后也就没有落笔。&lt;/p&gt;
&lt;p&gt; 然而，今天又有同事问起 Arch Linux，同事有一些 Linux 基础，对 Arch 比较好奇。
我想不如准备一些参考资料，说说自己作为 Arch 用户的使用心得，
来告诉新玩家 Arch 是什么，使用 Arch 会遇到怎样的问题，这样来得更实在一些。
像安装指南、发行版比较之类，已经有不少很好的资料了，实在不需要我的狗尾续貂。
此外，Arch 本身就不太适合刚刚接触 Linux 的玩家。而对于有一定 Linux 基础的玩家，
手把手地教人家怎样安装，应该这样，不要那样，这样才对，那样不对，
在我看来， 无异于对别人的一种不尊重。&lt;/p&gt;
&lt;p&gt; 综上种种，有了这篇小文。本文不会涉及具体的 Arch 安装步骤、详细 Arch 特性比较，
但我会给出这些资料的链接。此外，我会说说我的使用心得和一些 Arch 使用的小建议。&lt;/p&gt;
&lt;h1 id="arch-linux"&gt;Arch Linux 是什么？&lt;/h1&gt;
&lt;p&gt; 可以参考以下几篇文章，这些 wiki 页面中一般都有中文翻译页的链接，可自行跳转 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Arch_Linux"&gt;Arch Linux&lt;/a&gt; - Wikipeida 上的 “Arch Linux” 条目，涉及历史等一些基本信息 &lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/The_Arch_Way"&gt;The Arch Way&lt;/a&gt; - Arch Linux 的设计哲学，KISS。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/Arch_compared_to_other_distributions"&gt;Arch Compared to Others&lt;/a&gt; - Arch Linux 与其它发行版的比较，如果你是从其它发行版转过来，可以看看从 Arch 这里，你会得到什么，会失去什么，来帮助你选择。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/FAQ"&gt;Arch FAQ&lt;/a&gt; - 还有问题？可以翻翻这个 FAQ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 当然，介绍当中或多或少都有各种各样的忽悠，这里我讲一讲我三四年使用中，
感触最深的三点 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 滚动更新 &lt;/strong&gt;。Arch 采用的是滚动更动，没有 Ubuntu 和 Fedora 中发行版的概念。
你不需要在一个固定年限之后重装系统来保持更新。你的配置可以使用很多时间。
特别的，作为桌面系统，如果你把 &lt;code&gt;/home&lt;/code&gt; 挂载为一个单独的分区，
你甚至可以在 &lt;code&gt;/&lt;/code&gt; 挂掉之后，重装 Arch，挂回 &lt;code&gt;/home&lt;/code&gt;，然后惊喜的发现，
你 &lt;code&gt;/home&lt;/code&gt; 中的各种配置仍然可以正常工作。
不过这里要注意的是，Arch 的滚动更新不是完美的。在一些重大更新的时候，
需要手工配置一些东西，如果没有正确更新，下次直接进行系统整体更新的话，
有可能会让系统无法正常启动。2012-2013 年之间的 Systemd 和 Gnome3 切换，
就出现过这个问题，也吓走了一些 Arch 玩家。
不过，一般来说加入 Arch Announce 的邮件列表之后，重大更新都会在其中宣布。
一年最多也就一两次，不是很频繁。另外，即使系统挂掉了，使用 archboot 救援之后，
都会正常恢复的。比如像我，root 分区所在的 SSD 硬盘挂了两次
（硬件挂了两次，不是软件），&lt;code&gt;/home&lt;/code&gt; 中的资料、配置仍然都在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 活跃且友好的社区 &lt;/strong&gt;。&lt;a href="http://wiki.archlinux.org/"&gt;Arch Wiki&lt;/a&gt; 和 &lt;a href="http://bbs.archlinux.org/"&gt;Arch Forum&lt;/a&gt; 都是质量非常好的资源，
基本上 Arch 使用过程当中遇到的任何问题，都可以利用 wiki 自己解决。
如果真的没有相关的内容（在我自己的使用过程中目前还没有遇到这种情况），
你可以到论坛上求助，解答都非常热心。不过记得解决问题之后，
要去 wiki 更新一下相关页面。:)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 简洁的包管理格式 &lt;/strong&gt;。Arch 有自己的包管理系统 &lt;a href="https://wiki.archlinux.org/index.php/Pacman"&gt;Pacman&lt;/a&gt; 和包格式 &lt;a href="https://wiki.archlinux.org/index.php/PKGBUILD"&gt;PKGBUILD&lt;/a&gt;。
PKGBUILD 中可以写清楚信赖，源码的位置，编译和安装命令。基于 PKGBUILD，
Arch 官方提供了 AUR ( Arch User Repository )，可以让用户自己提交 PKGBUILD。
而其它用户可以通过 http 或者 &lt;code&gt;yaourt&lt;/code&gt; 或者 &lt;code&gt;packer&lt;/code&gt; 来下载 PKGBUILD，
进行包的编译和安装。也正因为这样，AUR 当中有很多最新的软件。&lt;/p&gt;
&lt;h1 id="arch-linux_1"&gt; 安装 Arch Linux&lt;/h1&gt;
&lt;p&gt; 详细的安装指导可以参考以下 wiki 页，页面中有对应的中文翻译页，请自行跳转 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/Installation_guide"&gt;Installation Guide&lt;/a&gt; - 精简版 &lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/Beginners'_Guide"&gt;Arch Beginner's Guide&lt;/a&gt; - 详细版 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 在安装之前，或许你会需要检查下你是否了解这些东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Uefi"&gt;UEFI&lt;/a&gt;/&lt;a href="https://en.wikipedia.org/wiki/GUID_Partition_Table"&gt;GPT&lt;/a&gt; 或者 BIOS/MBR - 我建议你使用 UEFI/GPT，不可否认，BIOS/MBR 正在被淘汰 &lt;/li&gt;
&lt;li&gt;LVM - 如果将 &lt;code&gt;/&lt;/code&gt;、&lt;code&gt;/home&lt;/code&gt;、&lt;code&gt;/var&lt;/code&gt; 放到 lvm 上的话，对于硬盘空间的充分利用和日后救援系统，都有不少裨益 &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Linux_boot_process"&gt;Linux Boot Process&lt;/a&gt; - 这会帮助你更好地理解 BootLoader、Kernel、Systemd/init 之间的关系，这有助于理解安装过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 在安装过程中，我建议你保持手边有第二台可以连网的设备，因为你可能要不时地查阅
&lt;a href="http://wiki.archlinux.org/"&gt;Arch Wiki&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id="_2"&gt; 安装之后 &lt;/h1&gt;
&lt;p&gt; 成功安装 Arch 之后，你应该可以启动到一个 shell，
虽然这个离一个真正的桌面系统还有点距离，不过已经很近了。
这里，我建议你休息一下，回顾一下安装过程中遇到的各种问题，
或许有针对性的记一些笔记会是个不错主意。如果以上的安装对你来说小菜一碟，
那么不用怀疑，你就是那个为 Arch 而生的人，坚定地走下去吧！:)&lt;/p&gt;
&lt;p&gt; 如果你决定继续进行，我建议你先从图形界面开始。什么？你在桌面系统上不用图形界面？
真有够硬核！如果你决定还是委屈地配合我一下，安装一个图形界面，可以参考 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/General_recommendations#Graphical_user_interface"&gt;Arch GUI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 安装完图形介面之后，基本上 Arch 的安装就可以告一段落了，
但是请检查你是否完成以下工作？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 加入 &lt;a href="https://mailman.archlinux.org/mailman/listinfo/arch-announce"&gt;Arch Announce&lt;/a&gt; 邮件列表，邮件量很少，一年十封左右，但是一旦有信，就意味着你在下次更新之前要仔细阅读，贸然更新可能会挂掉系统 &lt;/li&gt;
&lt;li&gt; 访问 &lt;a href="https://wiki.archlinux.org/index.php/Pacman_rosetta"&gt;Pacman Rosetta&lt;/a&gt;，提供了一个 &lt;code&gt;pacman&lt;/code&gt; 与 &lt;code&gt;yum&lt;/code&gt; 和 &lt;code&gt;apt-get&lt;/code&gt; 之间对应命令的参考。日常使用中，你可能还有用到 &lt;a href="https://wiki.archlinux.org/index.php/Pacman_Tips"&gt;Pacman Tips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 从 AUR 安装 &lt;code&gt;yaourt&lt;/code&gt; 或者 &lt;code&gt;packer&lt;/code&gt;，这应该是第一个也是最后一个你需要手工安装的 AUR 包 , 具体步骤可以参考 &lt;a href="https://wiki.archlinux.org/index.php/AUR"&gt;AUR&lt;/a&gt;。如果有必要，可以参考 &lt;a href="https://wiki.archlinux.org/index.php/Yaourt"&gt;Yaourt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 如果你以前没有使用过 &lt;code&gt;systemd&lt;/code&gt;，那么你应该访问 &lt;a href="https://wiki.archlinux.org/index.php/Systemd"&gt;Systemd&lt;/a&gt;，目前很多发行版都已经有了 &lt;a href="https://en.wikipedia.org/wiki/Systemd#Adoption"&gt; 迁移计划 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 如果你使用 &lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt;，要注意 Arch 官方源当中既有 python2 也有 python3。一般 &lt;code&gt;python&lt;/code&gt; 默认解析到 &lt;code&gt;python3&lt;/code&gt;，要使用 2 版的解析器，必须使用 &lt;code&gt;python2&lt;/code&gt;。不太方便？可以参考使用 virtualenv 和 virtualenvwrapper，如果你真的是一个 pythoner，你会知道去哪里找这两个模块的源码和文档 &lt;/li&gt;
&lt;li&gt; 最后，请从 AUR 安装 &lt;code&gt;archey&lt;/code&gt;, 并且执行它 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 还想玩更多？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 通读 &lt;a href="https://wiki.archlinux.org/index.php/General_recommendations"&gt;Arch Recommendations&lt;/a&gt;，看看大家有什么好东西推荐，或者你可以浏览 &lt;a href="https://wiki.archlinux.org/index.php/List_of_applications"&gt;Application List&lt;/a&gt;，看看有没有什么你想推荐给大家 &lt;/li&gt;
&lt;li&gt; 参与 &lt;a href="http://wiki.archlinux.org/"&gt;Arch Wiki&lt;/a&gt; 的条目编写和 &lt;a href="http://bbs.archlinux.org/"&gt;Arch Forum&lt;/a&gt; 的讨论吧 &lt;/li&gt;
&lt;li&gt; 提交向一个自己的 AUR，不过可能你需要了解一下 &lt;a href="https://wiki.archlinux.org/index.php/ABS"&gt;ABS&lt;/a&gt;，当然还有 &lt;a href="https://wiki.archlinux.org/index.php/PKGBUILD"&gt;PKGBUILD&lt;/a&gt; 和 &lt;a href="https://wiki.archlinux.org/index.php/AUR"&gt;AUR&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_3"&gt; 结语 &lt;/h1&gt;
&lt;p&gt; 欢迎入伙！快去编写 &lt;a href="http://wiki.archlinux.org/"&gt;Arch Wiki&lt;/a&gt; 和提交 &lt;a href="https://wiki.archlinux.org/index.php/AUR"&gt;AUR&lt;/a&gt; 包，来纳你的投名状吧！&lt;/p&gt;
&lt;p&gt; 但请记住，人生总是很艰难，有一股黑暗势力每年都会入侵一次 Arch 的世界。
它们会以各种方式来破坏 Arch 世界的和谐，包括但不限于 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 利用原力损毁你的硬盘 &lt;/li&gt;
&lt;li&gt; 利用意识控制让你忘记查看 &lt;a href="https://mailman.archlinux.org/mailman/listinfo/arch-announce"&gt;Arch Announce&lt;/a&gt;，或执行 &lt;code&gt;rm -rf *&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 做为一名正义的 Archer，你会使用 &lt;a href="https://wiki.archlinux.org/index.php/archboot"&gt;Archboot&lt;/a&gt; 来维护世界和平的，对吗？&lt;/p&gt;</summary><category term="archlinux"></category></entry><entry><title>利用耗怒回血解决野蛮人的战斗恢复问题</title><link href="http://yuex.in/post/2014/03/diablo3-barb-build.html" rel="alternate"></link><updated>2014-03-30T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2014-03-30:post/2014/03/diablo3-barb-build.html</id><summary type="html">&lt;h1 id="build"&gt;Build 介绍 &lt;/h1&gt;
&lt;p&gt; 在《夺魂之镰》之中，
由于 “ 生命窃取 ” 的去除和 “ 战斗暴怒 ” 与 “ 狂战之怒 ” 两个技能某些符文的修改，
在之前版本中广泛流行的 “ 双旋风 ”build 已经跑不起来了。
作为近战职业之一的野蛮人，寻找新的战斗恢复方式迫在眉睫。
在本文中我想到和试验了一个围绕被动技能 “ 嗜血狂人 ” 建立的 build，
可以在不牺牲装备上任何主要属性的前提之下（不会牺牲 dps），
通过合理搭配稀有装备的属性，让野蛮人达到战撸苦痛 I、II、III 的目的。&lt;/p&gt;
&lt;p&gt; 以下会先说明耗怒回血的原理，接着会根据这个原理展示我目前在用的几个 build，
和几个可能的变种 build。最后是装备选择和巅峰点数的选择。
各位读者可以根据耗怒回血的原理自由发挥，选择自己喜欢的技能奋战《夺魂之镰》。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 耐性不够的朋友可以直接跳转到 “ 技能选择 ” 章节，但我还是建议你看完原理部分 &lt;/strong&gt;&lt;/p&gt;
&lt;h1 id="build_1"&gt;Build 特点 &lt;/h1&gt;
&lt;p&gt; 优势 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 治疗的提升不以牺牲 dps 和 ehp 为前提，充分利用装备上的词缀，让三者可以共同提升，互不干扰 &lt;/li&gt;
&lt;li&gt; 渐进的装备更新路线，不需要特定传奇的支持，野蛮人可以从稀有装备慢慢过渡到传奇 &lt;/li&gt;
&lt;li&gt; 较好的技能兼容，围绕耗怒回血，可以选择先祖之锤，旋风斩，跃击，抛尸，山崩地裂等多个技能打造个性化的 build。这是一个 build，却又不是仅仅一个 build，选你所爱，爱你所选，自行车谁爱骑谁骑 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 劣势 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 无怒气时，非常危险。可以考虑巅峰点数选择击中恢复，提供额外的生命恢复手段 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_1"&gt; 耗怒回血的原理 &lt;/h1&gt;
&lt;p&gt; 以下会说明耗怒回血的原理和其有效性，以及装备上必要的词缀选择。&lt;/p&gt;
&lt;h2 id="_2"&gt; 被动技能 " 嗜血狂人 "&lt;/h2&gt;
&lt;p&gt; 游戏中对于 “ 嗜血狂人 ” 效果的描述为 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 毎消耗一点怒气恢复 578 点生命值，治疗量加成为生命之球效果加成的 1%&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 这个描述稍有模糊。实际的效果是野蛮人毎点怒气消耗的血量恢复值为
基础值 578 加上 “ 生命之球与药水恢复量 ” 总和乘以 0.01。
举例来说，野蛮人从装备上获得的 “ 生命之球与药水恢复量 ” 总和为 113,000，
则这个加成为 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;113000&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.01&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1130&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 这样，实际的毎点怒气消耗的血量恢复将变为 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;578&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1130&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1708&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_3"&gt; 耗怒回血的有效性 &lt;/h2&gt;
&lt;p&gt; 虽然上面这个数字 1708 看似不起眼，但请注意这是毎点怒气消耗产生的回血量，
对于一个消耗 20 点怒气的技能（先祖之锤，战斗暴怒），
实际的血量恢复将会是（怒气消耗降低为 0 的情况下）&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1708&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;34160&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 而一个护甲免伤和抗性免伤都在 75% 左右的野蛮人，
在苦痛 II 第三幕，血族打击者造成的伤害大约为 15,000 每次，
而结合主动免伤技能（战吼、霸气无伤反伤、忘却痛苦等），这个数值还要大幅降低。
我们以主动技能免伤 35%（霸气无双反弹伤害符文）来计算，
一次先祖之锤带来的血量恢复，相当于 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;34160&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mi"&gt;15000&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.65&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.50&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 个杂兵的伤害。此外，由于一般怪物的攻击速度要明显低于野蛮人，
以双持毎秒攻击次数 1.5（考虑了野蛮人的攻击速度加成），
怪物毎秒攻击次数 1.0（无公开数据，目测）计算，我们前面提到的数字会变为 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mf"&gt;3.50&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;5.25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 换言之，只有当 6 个及以上的杂兵围殴野蛮人的时候，野蛮人才会出现血量下降。
而血族打击者的模型较大，6 个左右基本上会将野蛮人包围起来，
所以野蛮人不会再受到额外血族打击者的攻击伤害。
此外，如果野蛮人的 dps 不是很低的话，选择合适的难度，
基本可以在血族打击者造成明显血量下降之前将其消灭。
所以野蛮人实际可以承受的围殴数字还要高很多。&lt;/p&gt;
&lt;p&gt; 虽然游戏当中的怪物各类多种多样，但是他们的伤害大小、攻击速度、模型大小，
基本符合 “ 体型越大，攻击速度越慢，伤害越高 ” 的规律。因此，上面所讲的例子当中，
野蛮人被围殴时，可能受到的总伤害量并不会有太大的变化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 我要打十个！
  &lt;small&gt; 甄子丹 &lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_4"&gt; 耗怒回血的词缀成本 &lt;/h2&gt;
&lt;p&gt; 相比于 “ 毎秒生命恢复 ” 和 “ 击中生命恢复 ”，耗怒回血最大的不同是词缀成本非常低。
秒回和击回做为装备上的主要属性，会占据一个主要属性词缀。
而每一件装备上只能有 4 个主要属性，选择秒回和击回，
就意味着必须要牺牲一条可以提升 dps 或者 ehp 的词缀。
相比之下，耗怒回血所需要的 “ 生命之球与药水恢复 ” 在装备上是做为次要属性出现的，
完全可以在不牺牲 dps 和 ehp 的情况下兼顾。例如，
已经有 4 条不错的主要属性（力量 / 体能 / 全抗 / 镶孔，或者力量 / 爆击 / 爆伤 / 攻速）
的稀有装备可以考虑将其中的次要属性重铸为 “ 生命之球与药水恢复量 +N”；
而已经有 “ 生命之球与药水恢复量 +N” 这条次要属性的装备，
可以考虑将其中一条不太好主要属性重铸为更有用的属性，
如秒回重铸为体能或者全抗。
如此一来，也能使得装备上的词缀利用更充分（其它次要属性大部分为可有可无的属性）。&lt;/p&gt;
&lt;p&gt; 除此之外，“ 生命之球与药水恢复量 ” 本身也是一条不错的词缀。
目前，生命药水的效果是恢复英雄 60% 的生命，以一个血量 450,000 的野蛮人为例，
一次生命药水可以恢复血量 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;450&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mo"&gt;000&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.60&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;270&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mo"&gt;000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;“ 生命之球与药水恢复量 ” 可以出现在肩 / 胸 / 足 / 项链 / 戒指 1/ 戒指 2，共 6 件装备上，
词缀取值范围约 14,000~20,000，以 17,000 计算，6 件装备可以产生的加成总量为 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mo"&gt;000&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;102&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mo"&gt;000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 所以使用一次生命药水，可以恢复生命 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;102&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mo"&gt;000&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;270&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mo"&gt;000&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;372&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mo"&gt;000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 的生命。这相当于 83% 的生命量。换言之，
当野蛮人需要使用生命药水时（一般是血量低于 20% 的时候），
一个生命药水就可以将野蛮人的生命全部补满。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 三精牌葡萄糖酸锌口服液，我只喝红瓶的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="_5"&gt; 技能选择 &lt;/h1&gt;
&lt;p&gt; 这里会先会针对伤害输出、耗怒回血、怒气产生、走位等 内容做一点讨论，
之后会根据讨论结果给出几个可以兼容几种常见的技能的 build 变种。
各位读者可以进一步发挥 &lt;/p&gt;
&lt;h2 id="_6"&gt; 伤害输出 &lt;/h2&gt;
&lt;p&gt; 先祖之锤配合战斗暴怒（血溅八方），即可以作为单体输出，
也可以利用溅射伤害作为小范围群体输出。
这里我推荐恶魔铁贴这个符文，是因为所带的减速效果，
在击杀哥布林和远程怪时，具有非常好的控制效果。&lt;/p&gt;
&lt;p&gt; 山崩地裂的怒气消耗减 CD 和耗怒回血一样，需要的快速消耗怒气。
将其做为主要的输出技能也是不错的选择。&lt;/p&gt;
&lt;p&gt; 上古之矛（巨岩怒掷）消耗所有怒气，也是个不错的输出技能。&lt;/p&gt;
&lt;h2 id="_7"&gt; 耗怒回血 &lt;/h2&gt;
&lt;p&gt; 站桩砸先祖之锤是最主要的耗怒回血方式，提供了一种小量持续的生命恢复。&lt;/p&gt;
&lt;p&gt; 上古之矛（巨岩怒掷）消耗所有怒气，可以做为一个大治疗存在。&lt;/p&gt;
&lt;p&gt; 战斗暴怒的 20 点怒气消耗也可以作为额外的回血手段。&lt;/p&gt;
&lt;h2 id="_8"&gt; 怒气产生 &lt;/h2&gt;
&lt;p&gt; 无可饶恕提供稳定的毎秒怒气累积。&lt;/p&gt;
&lt;p&gt; 战吼（迎敌怒喝）加怒气提供了不错的怒气爆发，
可以视情况切换（顽抗战吼）加抗性，或者（鼓舞土气）加秒回。&lt;/p&gt;
&lt;p&gt; 迷信提供了某些精英战中额外的怒气产生，踩着好几个瘟疫和亵渎砸先祖之锤，
怒气可以达到不衰退。&lt;/p&gt;
&lt;p&gt; 山崩地裂可以搭配被动技能大地之怒，来提供怒气。这里我推荐（天崩地裂）这个符文，
累积 3 次，想用就用。&lt;/p&gt;
&lt;p&gt; 狂暴冲锋（韧劲）毎击中一个敌人就产生 10 点怒气，还可以提供一个走位方式。&lt;/p&gt;
&lt;p&gt; 狂乱等主要技能作为额外的怒气补充，可以用来应对某些尴尬的情况。
这里我推荐选择了（狂人）加伤害，可以根据喜好选择其它符文。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I'm the special one.
  &lt;small&gt;Mourinho&lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_9"&gt; 伤害减免 &lt;/h2&gt;
&lt;p&gt; 战吼提供护甲加成，队友也能享受得到。&lt;/p&gt;
&lt;p&gt; 霸气无双（制敌先机）提供了 35% 的伤害减免。虽然这不是野蛮人减伤最高的技能，
但结合先祖之锤在满怒时的高爆击，可以很快地触发霸气无双的爆击减 CD，
提供非常不错的伤害减免覆盖。更可贵的是这 35% 的伤害减免会反弹给攻击者。&lt;/p&gt;
&lt;p&gt; 威吓怒吼也是个不错的选择，虽然减伤比例低，但是覆盖时间更长，操作更安逸。&lt;/p&gt;
&lt;p&gt; 忘却痛苦 CD 过长，目前来看不是一个太好的选择。&lt;/p&gt;
&lt;h2 id="_10"&gt; 走位 &lt;/h2&gt;
&lt;p&gt; 跃击可以提供一种霸气的走位方式，我推荐使用（亚瑞特的呼唤）
同时具有小范围拉怪的能力，组队时有不错的救驾队友的功能，可以视情况选择其它符文。
在某些特定地图中，跃击还可以像传送一样达到快速旅行的目的。&lt;/p&gt;
&lt;p&gt; 狂暴冲锋的（韧劲）加怒气、（绝情猛攻）减 CD，都是不错的走位技能，
有传奇支持后，冲锋这个技能会更神。&lt;/p&gt;
&lt;p&gt; 旋风斩（烈风剪）加怒气。要注意的是，旋风斩是个消耗 10 点怒气的技能，
配合耗怒回血，等于是享受了（集血斩）这个符文，
喜欢旋风斩的朋友可以尝试开着霸气无双的反伤来转怪群，回血又回怒，感觉不错。&lt;/p&gt;
&lt;h2 id="_11"&gt; 免疫控制 &lt;/h2&gt;
&lt;p&gt; 势不可当做为主要的控制免疫技能，提供 30% 的时间缩短，
而且有一定机率恢复 20% 的生命，经常在血不满的情况下被控制，然后瞬间血就满了。
这个被动技能还可以通过装备上的另外一个次要属性 “ 控场时间缩短 ” 来进一步缩短时间，
感觉应该可以达到被控制一下，立刻解除，还有机会恢复 20% 的血量。
实际上装备上的时间缩短加上这个被动，是可以达到 100% 控场时间缩短的，
但是不确定是否 100% 控场时间缩短之后还会触发势不可挡的回血特效。
由于目前装备有限，这个我还没有进行测试。&lt;/p&gt;
&lt;p&gt; 狂战之怒由于超长的 CD，目前来看性价比不高。&lt;/p&gt;
&lt;h2 id="_12"&gt; 技能变种 &lt;/h2&gt;
&lt;h3 id="1"&gt; 变种 1：组队坦克 &lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt; 撼山易，撼岳家军难 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="barb-build-tank" src="/image/diablo3-build/barb-build-tank.jpg" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 鼠标左键：狂乱（狂人）&lt;/li&gt;
&lt;li&gt; 鼠标右键：跃击（亚瑞特呼唤）&lt;/li&gt;
&lt;li&gt; 一号按键：先祖之锤（恶魔铁砧）&lt;/li&gt;
&lt;li&gt; 二号按键：霸气无双（制敌先机）&lt;/li&gt;
&lt;li&gt; 三号按键：战斗暴怒（血溅八方）&lt;/li&gt;
&lt;li&gt; 四号按键：战吼（迎敌怒喝）&lt;/li&gt;
&lt;li&gt; 被动技能：无可饶恕，迷信，嗜血狂人，势不可当 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 先祖之锤结合霸气无双的反伤，站桩扛精英游刃有余；
配合战斗暴怒（血溅八方）也有不错的群伤能力。
这里推荐（恶魔铁砧）减速符文，击杀哥布林和组队控制精英怪可以更游刃有余。&lt;/p&gt;
&lt;p&gt; 跃击相比冲锋和旋风斩，移动速度要快很多，这里选择（亚瑞特呼唤）具有拉怪功能，
非常适合组队救驾。试想一下，某个女猎魔人正在被杂兵纠缠骚扰，一名野蛮人从天而降，
英雄救美，何等霸气。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 我的意中人是个盖世英雄，有一天他会踩着七色的云彩来娶我。
  &lt;small&gt; 大话西游 &lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="2"&gt; 变种 2：旋风斩 &lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt; 其疾如风，其徐如林，侵掠如火，不动如山
  &lt;small&gt; 孙子兵法 ・ 军争 &lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="barb-build-whirlwind" src="/image/diablo3-build/barb-build-whirlwind.jpg" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 鼠标左键：狂乱（狂乱先驱）&lt;/li&gt;
&lt;li&gt; 鼠标右键：旋风斩（烈风剪）&lt;/li&gt;
&lt;li&gt; 一号按键：先祖之锤（恶魔铁砧）&lt;/li&gt;
&lt;li&gt; 二号按键：霸气无双（制敌先机）&lt;/li&gt;
&lt;li&gt; 三号按键：战斗暴怒（血溅八方）&lt;/li&gt;
&lt;li&gt; 四号按键：山崩地裂（天崩地裂）&lt;/li&gt;
&lt;li&gt; 被动技能：无可饶恕，迷信，嗜血狂人，大地之怒 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 这个变种中使用山崩地裂（天崩地裂）配合大地之怒提供较高的怒气产生。
由于放弃了势不可当的控制减免，需要通过装备上的控场减免来弥补。&lt;/p&gt;
&lt;p&gt; 旋风斩推荐（烈风剪）回怒，一旦怒气偏少，只要停下来放一个山崩地裂就可以继续上路了 &lt;/p&gt;
&lt;p&gt; 这里，狂乱选择了（狂乱先驱）增加移动速度，让旋风斩更流畅。&lt;/p&gt;
&lt;p&gt; 此外，先祖站桩过程中，使用山崩地裂还可以提供额外的伤害输出。&lt;/p&gt;
&lt;h3 id="3"&gt; 变种 3：巨岩怒掷 &lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt; 力拔山兮气盖世
  &lt;small&gt; 垓下歌 &lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="barb-build-rock" src="/image/diablo3-build/barb-build-rock.jpg" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 鼠标左键：狂乱（天袭）&lt;/li&gt;
&lt;li&gt; 鼠标右键：跃击（烈风剪）&lt;/li&gt;
&lt;li&gt; 一号按键：上古之矛（巨岩怒掷）&lt;/li&gt;
&lt;li&gt; 二号按键：霸气无双（制敌先机）&lt;/li&gt;
&lt;li&gt; 三号按键：战斗暴怒（血溅八方）&lt;/li&gt;
&lt;li&gt; 四号按键：战吼（迎敌怒喝）&lt;/li&gt;
&lt;li&gt; 被动技能：无可饶恕，迷信，嗜血狂人，怒意高涨 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 旋风斩用来提供小量的生命恢复，同时提供走位。&lt;/p&gt;
&lt;p&gt; 巨岩怒掷作为主要的输出技能，同时提供大量的生命恢复。
因此，当血量下降到 40% 时使用巨岩怒掷会有比较好的利用率。&lt;/p&gt;
&lt;p&gt; 因为装备水平不高的时候，怒气产生的比较慢，所以这里选择了怒意高涨，
战吼（迎敌怒喝），和旋风斩（烈风剪）。同时无怒气就不能进行耗怒回血，
所以这里选择了狂乱（天袭），来让精英战中的怒气累积更安全。&lt;/p&gt;
&lt;p&gt; 由于经常处于怒气匮乏和贫血的状态，大家可以关注下
踏泥铁头靴的 “ 生命损失提高移动速度 ” 和清水羽织的 “ 生命低于 20% 攻击一定爆击 ”，
当然还有夺魂者裹腕的 “ 生命之球恢复 25% 主要能理 ”。&lt;/p&gt;
&lt;h1 id="_13"&gt; 装备选择 &lt;/h1&gt;
&lt;h2 id="_14"&gt; 武器 &lt;/h2&gt;
&lt;p&gt; 由于耗怒回血需要较快地倾泻怒气，所以推荐使用双持。
此外，双持武器的高攻速也有利于快速将霸气无双的 CD 置零。&lt;/p&gt;
&lt;h2 id="_15"&gt; 生命之球恢复词缀选择 &lt;/h2&gt;
&lt;p&gt; 如前所述，“ 生命之球与药水恢复量 +N” 可能出现在肩 / 胸 / 足 / 项链 / 戒指 1/ 戒指 2，
共 6 个位置，取值范围为 14,000~20,000，可以期待的总量是 170,000，
会提供毎点耗怒恢复 1700 点生命。&lt;/p&gt;
&lt;p&gt; 已经有 4 条不错的主要属性的稀有装备，
例如力量 / 体能 / 全抗 / 镶孔，或者力量 / 爆击 / 爆伤 / 攻速，
可以考虑将其中的次要属性重铸为 “ 生命之球与药水恢复量 +N”；
而已经有 “ 生命之球与药水恢复量 +N” 这条次要属性的装备，
可以考虑将其中一条不太好主要属性重铸为更有用的属性，
如秒回重铸为体能或者全抗。&lt;/p&gt;
&lt;h2 id="_16"&gt; 控场时间缩短词缀选择 &lt;/h2&gt;
&lt;p&gt; 这个词缀可以出现在头 / 项链 / 戒指 1/ 戒指 2，共 4 个位置，取值范围为 10%~20%。
由于是次要属性，可以考虑在保证生命之球回复加成的前提，尽量兼顾这条词缀 &lt;/p&gt;
&lt;h2 id="_17"&gt; 消耗怒气回血 &lt;/h2&gt;
&lt;p&gt; 重型腰带上，这条词缀会以主要属性的方式出现，是否重铸或保留这条词缀，
大家可以根据情况决定，由于这条词缀的上限不超过 200，
所以即使没有，也不会产生很大的影响。
此外，要注意的是不朽之王的套装奖励也有这条词缀 &lt;/p&gt;
&lt;h1 id="_18"&gt; 巅峰点数 &lt;/h1&gt;
&lt;p&gt; 额外需要注意的是辅肋中不要使用 “ 能量消耗降低 ”，因为就是需要用怒气消耗来恢复血量。
这里推荐使用击中生命恢复，可以提供额外的战斗恢复补充。&lt;/p&gt;
&lt;h1 id="_19"&gt; 结语 &lt;/h1&gt;
&lt;p&gt; 是男人就要刚正面 &lt;/p&gt;
&lt;p&gt;&lt;img alt="barb-xuyunlong" src="/image/diablo3-build/barb-xuyunlong.jpg" /&gt;&lt;/p&gt;</summary><category term="diablo3"></category></entry><entry><title>如何撰写技术文档</title><link href="http://yuex.in/post/2014/01/technical-writing.html" rel="alternate"></link><updated>2014-01-29T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2014-01-29:post/2014/01/technical-writing.html</id><summary type="html">&lt;p&gt; 这个页面包含一些我收集的与写作相关的资料。虽然其中一些原则是通用的，但这些资料主要还是针对计算机学科的技术写作的，如学术论文、技术文档。&lt;/p&gt;
&lt;p&gt; 如果你时间非常有限，我推荐以下两个文档 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt;Michael Ernst's &lt;a href="http://homes.cs.washington.edu/~mernst/advice/write-technical-paper.html"&gt;Writing a Technical Paper&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Michael Ernst 给出一些关于会议论文写作的建议，包含了从文章构思、提纲拟定、写作风格、图表表现、命名、处理评审意见等多个方面。此外，Michael 的个人主页上还有很多有益于学术生涯的其它方面的建议，也非常值得一读。&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt;Norman Ramsey's &lt;a href="http://www.cs.tufts.edu/~nr/pubs/two-abstract.html"&gt;Learning Technical Writing in Two Hours per Week&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Norman Ramsey 总结了 9 条科技写作原则，并设计了 7 个练习来帮助掌握这些原则。相比 Michael 的建议，Norman 的建议更精炼，更适合用来强化掌握。&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 如果你时间多一点，我额外推荐两本书 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt;The Elements of Style, William Strunk Jr. and E.B. White&lt;/dt&gt;
&lt;dd&gt;ISBN: 9780205632640。需要注意的是，Strunk 的原版和 E.B. White 修订后的版本有比较大的不同。这里推荐的是 White 修订后的版本。&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt;Style: Toward Clarity and Grace, Joseph M. Williams&lt;/dt&gt;
&lt;dd&gt; 一句话评价稍后奉上 &lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 如果还想提高英语读写的话，我推荐以下两本书 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt;Triple Your Reading Speed, Wade E. Cutler&lt;/dt&gt;
&lt;dd&gt; 本书讲述了速读术的基本原理，并辅以相应练习来帮助读者掌握。当然，掌握原理后的认真练习仍然是必不可少的。外研社出过一版该书的影印版，ISBN: 9787560045399&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;dl&gt;
&lt;dt&gt; 文法俱乐部，旋元佑 &lt;/dt&gt;
&lt;dd&gt;ISBN: 9789578302006。该书从句子合成与简化的角度来讲解英语语法，深入浅出，将繁杂语法规则精炼为几条原则，来教会读者触类旁通。由于出版社倒闭，该书已经绝版，有一些扫描版流传于网络 &lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>动手写PAM模块让sshd支持用户接入控制</title><link href="http://yuex.in/post/2013/09/hands-on-pam-module-and-sshd.html" rel="alternate"></link><updated>2013-09-29T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2013-09-29:post/2013/09/hands-on-pam-module-and-sshd.html</id><summary type="html">&lt;p&gt; 承接上一篇 blog，某本意是想用 pam_limits.so 来做用户登录限制，从而可以让多个用户共用一台机器做 ssh 代理。这样一来，服务器端就必须要对用户进行基于用户名和登录 ip 的。&lt;/p&gt;
&lt;p&gt; 想当然的做法是用 /etc/security/limits.conf 中的 maxlogins 解决。但是这个是有问题的，maxlogins 是要用户登录到 shell 才会统计的。pam_limits.so 中读取的是 utmp，这个是存在 /var/run/utmp 中的，用 &lt;code&gt;w&lt;/code&gt; 可以查看。而 &lt;code&gt;ssh -N&lt;/code&gt; 是不会被 utmp 记录为 login 的。所以，如果用上篇 blog 中的方法实践的话，用户可以用 &lt;code&gt;ssh -N&lt;/code&gt; 绕过所有的接入控制。一般而言，这也不是什么大问题，因为用户 &lt;code&gt;ssh -N&lt;/code&gt; 接入的话，只能做端口转发这一件事情。而若 sshd 禁用端口转发的话，这个也就只能用来攻击了，而这种又太容易防范了（做贼还要用真名吗），所以也不会够成实质性的威胁。&lt;/p&gt;
&lt;p&gt; 但对于希望把端口转发做为一项服务的某来话，这就是个大问题了。一项服务，如果不能进行用户权限控制的话，那只能算是自己给自己开了一个安全漏洞。解决的方法，最好就是 ssh 可以提供相应的功能。但目前来看，似乎不太可能。而且即使有这个可能，自己动手 commit 的话，直到 merge 也要太长的周期。所以某转而来调研 pam 是不是也能实现这个功能。&lt;/p&gt;
&lt;p&gt; 答案是肯定的。而且更加方便的方法是用 pam_script.so 来做这件事。在进行账户验证的时候，执行脚本，来完成对 ssh 接入用户数和用户 ip 的检查，从而完成对单个账号登录和单个 ip 登录数目的限制。可惜的是，pam 的发行包中没有 pam_script 这个模块。网上可以找到一些别人写的，但大多语焉不详，有的是 doc 一笔带过，有的是编译无法一次通过。此外，某发现这些 pam_script.so 的实现，都只能针对 auth，password 和 session 进行插入，而独没有 account。根据 &lt;code&gt;man pam&lt;/code&gt; 中的解释 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;account - provide account verification types of service: has the user's password expired?; is this user permitted access to the requested service?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 似乎 account 才是最符合某的接入控制需求的。所以，某决定还是自己动手写一个简单的 pam_script.so 吧。对于如何写一个 pam module，可以参考 &lt;a href="http://www.rkeene.org/projects/info/wiki/222"&gt; 这个 &lt;/a&gt; 和 &lt;a href="http://www.freebsd.org/doc/en/articles/pam/article.html#pam-sample-module"&gt; 这个 &lt;/a&gt;。因为我只做 account 用，所以只要实现 &lt;code&gt;pam_sm_acct_mgmt&lt;/code&gt; 就可以了。只要在 C 中指定一个脚本路径，然后用一些参数调用这个脚本，并读取返回值就可以了。而外部脚本，可以使用 shell script，也可以使用 python，对登录数目的统计可以用 &lt;code&gt;ps&lt;/code&gt; 和 &lt;code&gt;netstat&lt;/code&gt;，只要检查完把结果返回给 &lt;code&gt;pam_script.so&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt; 最后一步，不要忘记把 &lt;code&gt;pam_script.so&lt;/code&gt; 加入到 /etc/pam.d/sshd 中 &lt;/p&gt;
&lt;p&gt; 因为目前某的 vps 还在做小范围的测试，代码要晚点才能放到 github 上。&lt;/p&gt;</summary><category term="sshd"></category><category term="pam"></category><category term="python"></category></entry><entry><title>配置sshd使用pam认证小结</title><link href="http://yuex.in/post/2013/09/config-sshd-using-pam.html" rel="alternate"></link><updated>2013-09-25T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2013-09-25:post/2013/09/config-sshd-using-pam.html</id><summary type="html">&lt;p&gt; 某今年新入了一台 linode 主机，最便宜的 plan，年中的时候，linode 流量从 2GB 免费升级到了 2TB。因为某的博客是直接放到 github 上的，所以对 linode 的使用一直都不怎么充分。仅限于几个朋友之间的 L2TP 和自己的 &lt;code&gt;ssh -D&lt;/code&gt;。一直都有一个架立一个 socks 伺服的想法，来给大家免费用。无奈于大部分的浏览器都不支持有密码的 socks 认证，如果架设一个没有验证的伺服又有很严重的管理和用户性能区分保证的问题，所以这个想法一直没有落实。今天花了一些时间，用 ssh＋pam＋chroot jail 完成了这个想法，将思路大概记录一下，希望对有同样需求的同学有所帮助。&lt;/p&gt;
&lt;p&gt;ssh＋pam＋chroot 各模块的功能如下 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ssh/sshd：client and server，支持密码用户 &lt;/li&gt;
&lt;li&gt;pam：提供基于用户名和 ip 地址段的登陆认证和限制 &lt;/li&gt;
&lt;li&gt;chroot：做成一个 chroot jail 限制用户在主机上的权限 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="chroot-jail"&gt;chroot jail&lt;/h2&gt;
&lt;p&gt; 在 sshd 中添加 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Match&lt;/span&gt; &lt;span class="n"&gt;Group&lt;/span&gt; &lt;span class="n"&gt;groupname&lt;/span&gt;
    &lt;span class="n"&gt;ChrootDirectory&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jail&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 这会使得 groupname 的用户在登陆 ssh 之后，会自动被 chroot 到管理员定义的 jail 到中，这里以 /path/to/jail 为例。这只是办了入狱手续，还要真正的建立监狱才行。chroot 之后，会自动调用 bash，要保证在这个路径下，bash 可以正常使用。只要用 &lt;code&gt;ldd&lt;/code&gt; 解析一下 bash 的依赖，然后将所以依赖放到这个路径下就可以了。监狱制成之后，要自己 &lt;code&gt;chroot&lt;/code&gt;&lt;del&gt; 体验 &lt;/del&gt; 验证一下。&lt;/p&gt;
&lt;h2 id="ssh"&gt;ssh&lt;/h2&gt;
&lt;p&gt;ssh 的问题主要是客户端。linux 和 mac 用户就不用说了，&lt;code&gt;ssh -D&lt;/code&gt; 可以直接参考 manpage，还不会的就去面壁吧。windows 下可以使用 putty，并且 putty 可以事先设置好，直接分发给用户。用户先建立 ssh 连接，再用浏览器 socks 连接到本地绑定的端口。更进一步可以通过安装浏览器插件来根据规则自动地应用 socks，比如 chrome 上可以使用 Proxy Swichy&lt;/p&gt;
&lt;h2 id="pam"&gt;pam&lt;/h2&gt;
&lt;p&gt;pam 有两方面的作用，一个是提供基于用户和地址的登陆验证，一个是限制用户使用系统资源。对于资源限制，主要是防止 fork bomb 和限制登陆数目。这两个都可以在 /etc/security/limits.conf 中完成。其实在 centos6 当中，对于 fork bomb 系统有防范，可以参考 /etc/security/limits.d/，这个值是 1024。另外，对于写的权限控制，最简单的方法是把 jail 建立在 /var 来解决，/var 对非 root:root 的用户是没有写的权限的。对于登陆验证，需要在 sshd_config 中打开 &lt;code&gt;UsePam yes&lt;/code&gt;，并且在 /etc/pam.d/sshd 中加入 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;account    required     pam_nologin.so
account    required     pam_access.so  &lt;span class="c1"&gt;# &amp;lt;- added line&lt;/span&gt;
account    include      password&lt;span class="o"&gt;-&lt;/span&gt;auth
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 此外还要在 /etc/security/access.conf 中写入具体的登陆控制，可以参考其中的 comments，支持用户和 ip 区分。注意这两个文件都是顺序解析的，First Come Firs Serve。所以要注意写入规则的顺序。&lt;/p&gt;
&lt;p&gt; 对于这样建立的 socks 伺服并非没有问题，比如 bandwidth 的限额。&lt;/p&gt;</summary><category term="sshd"></category><category term="pam"></category></entry><entry><title>terminal切换小结</title><link href="http://yuex.in/post/2013/09/terminal-switching.html" rel="alternate"></link><updated>2013-09-24T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2013-09-24:post/2013/09/terminal-switching.html</id><summary type="html">&lt;p&gt; 早就听说 xterm 和 urxvt 是轻量高可配置，所以想利用周末的时间把某现在在用的 terminator 切换到 xterm 或者 urxvt。结果放弃了。倒不是因为配置太过复杂，而是某觉得，在进行了一定配置之后，对比需求 / 成本 / 收益觉得，这样的配置不能称之为有效。某认为将这些东西总结一下，可能有助于有同样切换初衷的同学少走一些弯路。&lt;/p&gt;
&lt;p&gt; 某切换 terminal 的初始需求 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 可全屏 &lt;/li&gt;
&lt;li&gt; 支持 solarized 的颜色设置 &lt;/li&gt;
&lt;li&gt; 支持 inconsolata-g 和 wenquanyi 中文 &lt;/li&gt;
&lt;li&gt; 支持 tab&lt;/li&gt;
&lt;li&gt; 可以和 tmux 和 powerline 和谐相处 &lt;/li&gt;
&lt;li&gt; 轻量化 &lt;/li&gt;
&lt;li&gt;copy and paste&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 因为 urxvt 的初衷就是取代 xterm。而 terminator，konsole，gnome-terminal，xfce4-terminal 的设置都是大同小异。所以下面的讨论主要以 urxvt 和 terminator 为例。&lt;/p&gt;
&lt;p&gt; 第一条 &lt;/p&gt;
&lt;p&gt;urxvt 需要使用 wmctrl 来进行全屏控制，需要对 urxvt 进行 perl 扩展，可以参考 AUR 中的 urxvt-fullscreen&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。xterm 内建支持 fullscreen，只不过绑定键位是 Alt-Enter&lt;/p&gt;
&lt;p&gt; 第二条 &lt;/p&gt;
&lt;p&gt;urxvt 和 xterm 的颜色设置都是通过 .Xresources 或者 .Xdefaults 来进行的 ( 为个简便，以下仅用 .Xresources 进行指代 )。可以通过 &lt;code&gt;*color&lt;/code&gt; 的通位方式来让 xterm 和 urxvt 来使用相同的位置。但是一旦设置了 foreground color，那么在 vim 当中，就没 reverse video 的效果了。光标不会再根据当前 text 的语法高亮情况来变换光标颜色了 .。&lt;/p&gt;
&lt;p&gt; 第三条 &lt;/p&gt;
&lt;p&gt;urxvt 和 xterm 都可以设置两种字体。不同的是二者在 .Xresources 中的资源名是不同的。urxvt 通过 &lt;code&gt;URxvt.font: xft:*，xft:*&lt;/code&gt; 来指定，而 xterm 要分别使用 &lt;code&gt;xterm.faceName&lt;/code&gt; 和 &lt;code&gt;xterm.faceNameDoubleSize&lt;/code&gt; 来指定英文和中文字体。不过要注意的是，像某这样使用 inconsolata-g 有 &lt;code&gt;-&lt;/code&gt; 符号的，&lt;code&gt;fc-list&lt;/code&gt; 会显示实际的名字要使用 "Inconsolata-g"，这个用法在 &lt;code&gt;urxvt -fn&lt;/code&gt; 的选项中是没有问题的。但如果要将这个配置写入到 .Xresources 当中，要将 &lt;code&gt;\&lt;/code&gt; 再 escape 一次，变成 &lt;code&gt;URxvt.font:xft:Inconsolata\\-g&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 第四条 &lt;/p&gt;
&lt;p&gt;xterm 不支持。urxvt 要通过 perl 扩展。可以参考 tabbed 和 tabbedex&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;。tabbed 是 urxvt 自带的扩展。不同的是 tabbed 只支持新建 tab 和 tab 之间的切换，而 tabbedex 还额外支持 tab 重命名和 tab 位置的相互调换。tabbedex 可以参考 AUR 中的，但是要注意的是 tabbedex 的实现目前有 bug，要手动注释掉其代码中的 &lt;code&gt;on_user_command&lt;/code&gt; 函数，这个并不影响 tabbedex 的功能，只是一个留给用户进行键位绑定的 hook，可以 &lt;code&gt;man urxvtperl&lt;/code&gt; 确认。其实如果是配合 tmux 使用的话，tab 支持可以不考虑，可以用 tmux 的 window 来模拟 tab。&lt;/p&gt;
&lt;p&gt; 第五条 &lt;/p&gt;
&lt;p&gt;xterm 不能显示 powerline 中的 fancy symbol，即使将字体 patch 过也不行。urxvt 可以正常使用 powerline。但二者在配合 tmux 使用时，在使用 manpage 的时候，less 会的 reverse video 有问题，需要做一个 hack&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;。但是做完这个 hack 之后，会使得二者的可移植性大大降低。甚至在 urxvt 中使用 tmux 后，做 &lt;code&gt;sudo&lt;/code&gt; 的时候都会提示，root 下没有做这个 hack，更别说将这些配置直接拷贝到其它机器上了。需要将这个 hack 一同拷贝。&lt;/p&gt;
&lt;p&gt; 第六条 &lt;/p&gt;
&lt;p&gt; 不可否认 xterm 和 urxvt 都是轻量级的 terminal emulator，对系统资源占用较少。某粗略测算 urxvt 是 terminaotr 的 1/5，xterm 是 terminator 的 1/10。但考虑到目前笔电的硬件配置，系统资源占用少已经不能算是一个 killer feature 了。而且就算考虑到系统资源占用，完全可以换装 xfce4-terminal，它的资源使用和 urxvt 和 xterm 完全是可比的。再者说，也没有人会在高负载的 server 上使用图形介面吧 ? 如果还要使用 VNC 来连接 server 的话，这个做法本身就有问题了。&lt;/p&gt;
&lt;p&gt; 第七条 &lt;/p&gt;
&lt;p&gt;xterm 和 urxvt 都需要进行额外的配置。因为做到这一步，某已经决定就到这里了，所以就没有再继续进行这一项的具体配置了。&lt;/p&gt;
&lt;p&gt; 这上面几条来看，虽然 urxvt 和 xterm 可以在经过配置后达到这些目的，但是对应的移植性和维护性都要有所降低，与 terminaotr 这些 terminal 相比，已经不具有即装即用性了。当然，urxvt 也并非全然没有它的特点。比如，在 urxvt 中通过 perl 扩展，可以开启 url 选择模式，完全通过键盘就可以选择 url 并在 browser 中打开。还可以通过 &lt;code&gt;URxvt.colorUL&lt;/code&gt; 来让有下划线的 text 有不同的样式，这个在 manpage 中还是蛮方便的。&lt;/p&gt;
&lt;p&gt; 上所述，某最后决定还是继续使用 terminator 好了。正如一些同学批评的那样 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 有这个时间还不如多写现行代码 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="https://aur.archlinux.org/packages/urxvt-fullscreen/"&gt;https://aur.archlinux.org/packages/urxvt-fullscreen/&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;a href="https://aur.archlinux.org/packages/urxvt-tabbedex-git/"&gt;https://aur.archlinux.org/packages/urxvt-tabbedex-git/&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;&lt;a href="http://tmux.svn.sourceforge.net/viewvc/tmux/trunk/FAQ"&gt;http://tmux.svn.sourceforge.net/viewvc/tmux/trunk/FAQ&lt;/a&gt; search "reverse video"&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="terminal"></category><category term="xterm"></category><category term="urxvt"></category></entry><entry><title>Archlinux环境下pdf注记工具推荐</title><link href="http://yuex.in/post/2013/03/pdf-annotation.html" rel="alternate"></link><updated>2013-03-16T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2013-03-16:post/2013/03/pdf-annotation.html</id><summary type="html">&lt;p&gt; 从事学术工作的朋友可能像笔者一样，经常会遇到要帮助别人修改文章，或者自己阅读文献要进行批注的情况。由于并不是人人都使用 Linux 和 Latex，所以一般大家会默认地将写好的文章转换为 pdf 格式，然后再进行修改 &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。这样在 Linux 下选择一款得心应手的带有注记功能的 pdf viewer 软件就十分重要了。&lt;/p&gt;
&lt;p&gt; 在 Archlinux 上，有如下几种选择 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Okular          - extra, kde&lt;/li&gt;
&lt;li&gt;evince          - extra, gnome&lt;/li&gt;
&lt;li&gt;masterpdfeditor - aur&lt;/li&gt;
&lt;li&gt;xournal         - extra&lt;/li&gt;
&lt;li&gt;mendeleydesktop - aur&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 不过这些都和 Adobe Acrobat 的用户体验有所差距。有些虽然具有 sticky note 和 highlight 功能，但是 export 之后，在某些 pdf viewer 当中查看存在兼容性问题。几经比较，最后笔者选择了如下的组合 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.tracker-software.com/product/pdf-xchange-viewer"&gt;PDF-XChange Viewer&lt;/a&gt; - needs wine support&lt;/li&gt;
&lt;li&gt;acroread - aur, acrobat reader linux version&lt;/li&gt;
&lt;li&gt;mendeleydesktop&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PDF-Xchange Viewer 需要 wine 的支持，但却比较好的提供了与 acrobat pro 相同的体验，并且生成的注记内容的兼容性非常好。&lt;/p&gt;
&lt;p&gt;acroread 是 acrobat reader 的 linux 版本，可以用来验证 linux 下生成的 pdf 文档在 windows 上打开的效果。&lt;/p&gt;
&lt;p&gt;mendeleydesktop 的注记功能在输出的时候虽然存在兼容性的问题，但用来做个人的文献整理还是非常不错的。&lt;/p&gt;
&lt;p&gt; 另外，以下字体也比较建议安装 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ttf-mac-fonts - aur&lt;/li&gt;
&lt;li&gt;ttf-ms-fonts - aur&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 这两个字体基本提供了 mac 和 microsoft 系统常用的字体，可以保证不会出现字体缺少造成相同文档在不同系统上的字体差异 &lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt; 使用 word 的朋友，一定要先在 windows 上用 word 将 doc 文档转换好 pdf 再发给 Linux 的朋友进行修改。Linux 下虽然也可以对 doc 进行转换，但转换效果并不理想。&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="pdf"></category><category term="archlinux"></category></entry><entry><title>在shell中区分option与args</title><link href="http://yuex.in/post/2013/03/differ-optons-from-args-in-shell.html" rel="alternate"></link><updated>2013-03-02T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2013-03-02:post/2013/03/differ-optons-from-args-in-shell.html</id><summary type="html">&lt;p&gt; 使用 &lt;code&gt;--&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 如下，&lt;code&gt;-rf&lt;/code&gt; 会解析为 option，而 &lt;code&gt;--help&lt;/code&gt; 会解析为 args&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;rm -rf -- --help
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;code&gt;man bash&lt;/code&gt; 之后 &lt;code&gt;/--&lt;/code&gt;，可以了解更多信息 &amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="bash"></category></entry><entry><title>使用virtualenv要注意的地方</title><link href="http://yuex.in/post/2013/03/notes-for-virtualenv.html" rel="alternate"></link><updated>2013-03-02T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:yuex.in,2013-03-02:post/2013/03/notes-for-virtualenv.html</id><summary type="html">&lt;p&gt;virtualenv 是 pypi 当中的一个包，用来虚拟一个 python 环境。实现上就是单独建立一个 locallib，并将 python 和 pip 的命令解析到这个 local lib 中。一般而言是将这个 lib 放在 /home/user/ 的家目录下，区别于系统的 /usr/lib 目录。将之用于开发，可以隔离各个包的依赖关系。这在开发过程中，可以保证在版本变化的情况下，已安装好的包的依赖关系的版本不变。&lt;/p&gt;
&lt;p&gt; 由于目前 python2 和 python3 在很多 linux 发行版的源当中都是共存的，所以在使用 virtualenv 的时候要特别注意，用 &lt;code&gt;mkvirtualenv&lt;/code&gt; 新建 virtualenv 之后，其中的 python 和 pip 解析到什么样的命令。否则可以会造成安装偏差。&lt;/p&gt;
&lt;p&gt; 以笔者的系统为例 (archlinux, 2013-03-02)，python2.7 在系统上的命令是 python2，pip 是 pip2，
而 virtualenv 安装之后，默认的解析是 python2/python/python2.7, pip/pip2.7。如果不检查就直接用习惯的
pip2 安装的话，新的包就会安装到系统 lib 而不是新建的 virtualenv lib 中了。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;mkvirtualenv foo
&lt;span class="nv"&gt;$ &lt;/span&gt;lsvirtualenv foo
&lt;span class="nv"&gt;$ &lt;/span&gt;workon foo
&lt;span class="nv"&gt;$ &lt;/span&gt;cdvirtualenv
&lt;span class="nv"&gt;$ &lt;/span&gt;ll bin
&lt;span class="o"&gt;(&lt;/span&gt; 注意查看 python 和 pip 的名称 &lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;cdproject
&lt;span class="nv"&gt;$ &lt;/span&gt;finish the work
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 另外，安装 virtualenv 的时候也要注意使用的是 pip2 还是 pip3，不同版本下的 virtualenv 的命令解析名称也是不一样的。&lt;/p&gt;
&lt;p&gt; 更多信息，请访问 &lt;a href="http://www.virtualenv.org/"&gt;virtualenv&lt;/a&gt;&lt;/p&gt;</summary><category term="python"></category><category term="virtualenv"></category></entry></feed>