<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>yuex (悟道洞穴人)</title><link href="http://blog.yuex.in/" rel="alternate"></link><link href="http://localhost:8000/feeds/linux.atom.xml" rel="self"></link><id>http://blog.yuex.in/</id><updated>2013-09-29T00:00:00+08:00</updated><entry><title>动手写PAM模块让sshd支持用户接入控制</title><link href="http://blog.yuex.in/post/2013/09/hands-on-pam-module-and-sshd.html" rel="alternate"></link><updated>2013-09-29T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:blog.yuex.in,2013-09-29:post/2013/09/hands-on-pam-module-and-sshd.html</id><summary type="html">&lt;p&gt; 承接上一篇 blog，某本意是想用 pam_limits.so 来做用户登录限制，从而可以让多个用户共用一台机器做 ssh 代理。这样一来，服务器端就必须要对用户进行基于用户名和登录 ip 的。&lt;/p&gt;
&lt;p&gt; 想当然的做法是用 /etc/security/limits.conf 中的 maxlogins 解决。但是这个是有问题的，maxlogins 是要用户登录到 shell 才会统计的。pam_limits.so 中读取的是 utmp，这个是存在 /var/run/utmp 中的，用 &lt;code&gt;w&lt;/code&gt; 可以查看。而 &lt;code&gt;ssh -N&lt;/code&gt; 是不会被 utmp 记录为 login 的。所以，如果用上篇 blog 中的方法实践的话，用户可以用 &lt;code&gt;ssh -N&lt;/code&gt; 绕过所有的接入控制。一般而言，这也不是什么大问题，因为用户 &lt;code&gt;ssh -N&lt;/code&gt; 接入的话，只能做端口转发这一件事情。而若 sshd 禁用端口转发的话，这个也就只能用来攻击了，而这种又太容易防范了（做贼还要用真名吗），所以也不会够成实质性的威胁。&lt;/p&gt;
&lt;p&gt; 但对于希望把端口转发做为一项服务的某来话，这就是个大问题了。一项服务，如果不能进行用户权限控制的话，那只能算是自己给自己开了一个安全漏洞。解决的方法，最好就是 ssh 可以提供相应的功能。但目前来看，似乎不太可能。而且即使有这个可能，自己动手 commit 的话，直到 merge 也要太长的周期。所以某转而来调研 pam 是不是也能实现这个功能。&lt;/p&gt;
&lt;p&gt; 答案是肯定的。而且更加方便的方法是用 pam_script.so 来做这件事。在进行账户验证的时候，执行脚本，来完成对 ssh 接入用户数和用户 ip 的检查，从而完成对单个账号登录和单个 ip 登录数目的限制。可惜的是，pam 的发行包中没有 pam_script 这个模块。网上可以找到一些别人写的，但大多语焉不详，有的是 doc 一笔带过，有的是编译无法一次通过。此外，某发现这些 pam_script.so 的实现，都只能针对 auth，password 和 session 进行插入，而独没有 account。根据 &lt;code&gt;man pam&lt;/code&gt; 中的解释 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;account - provide account verification types of service: has the user's password expired?; is this user permitted access to the requested service?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 似乎 account 才是最符合某的接入控制需求的。所以，某决定还是自己动手写一个简单的 pam_script.so 吧。对于如何写一个 pam module，可以参考 &lt;a href="http://www.rkeene.org/projects/info/wiki/222"&gt; 这个 &lt;/a&gt; 和 &lt;a href="http://www.freebsd.org/doc/en/articles/pam/article.html#pam-sample-module"&gt; 这个 &lt;/a&gt;。因为我只做 account 用，所以只要实现 &lt;code&gt;pam_sm_acct_mgmt&lt;/code&gt; 就可以了。只要在 C 中指定一个脚本路径，然后用一些参数调用这个脚本，并读取返回值就可以了。而外部脚本，可以使用 shell script，也可以使用 python，对登录数目的统计可以用 &lt;code&gt;ps&lt;/code&gt; 和 &lt;code&gt;netstat&lt;/code&gt;，只要检查完把结果返回给 &lt;code&gt;pam_script.so&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt; 最后一步，不要忘记把 &lt;code&gt;pam_script.so&lt;/code&gt; 加入到 /etc/pam.d/sshd 中 &lt;/p&gt;
&lt;p&gt; 因为目前某的 vps 还在做小范围的测试，代码要晚点才能放到 github 上。&lt;/p&gt;</summary><category term="sshd"></category><category term="pam"></category><category term="python"></category></entry><entry><title>配置sshd使用pam认证小结</title><link href="http://blog.yuex.in/post/2013/09/config-sshd-using-pam.html" rel="alternate"></link><updated>2013-09-25T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:blog.yuex.in,2013-09-25:post/2013/09/config-sshd-using-pam.html</id><summary type="html">&lt;p&gt; 某今年新入了一台 linode 主机，最便宜的 plan，年中的时候，linode 流量从 2GB 免费升级到了 2TB。因为某的博客是直接放到 github 上的，所以对 linode 的使用一直都不怎么充分。仅限于几个朋友之间的 L2TP 和自己的 &lt;code&gt;ssh -D&lt;/code&gt;。一直都有一个架立一个 socks 伺服的想法，来给大家免费用。无奈于大部分的浏览器都不支持有密码的 socks 认证，如果架设一个没有验证的伺服又有很严重的管理和用户性能区分保证的问题，所以这个想法一直没有落实。今天花了一些时间，用 ssh＋pam＋chroot jail 完成了这个想法，将思路大概记录一下，希望对有同样需求的同学有所帮助。&lt;/p&gt;
&lt;p&gt;ssh＋pam＋chroot 各模块的功能如下 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ssh/sshd：client and server，支持密码用户 &lt;/li&gt;
&lt;li&gt;pam：提供基于用户名和 ip 地址段的登陆认证和限制 &lt;/li&gt;
&lt;li&gt;chroot：做成一个 chroot jail 限制用户在主机上的权限 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="chroot-jail"&gt;chroot jail&lt;/h2&gt;
&lt;p&gt; 在 sshd 中添加 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Match&lt;/span&gt; &lt;span class="n"&gt;Group&lt;/span&gt; &lt;span class="n"&gt;groupname&lt;/span&gt;
    &lt;span class="n"&gt;ChrootDirectory&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jail&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 这会使得 groupname 的用户在登陆 ssh 之后，会自动被 chroot 到管理员定义的 jail 到中，这里以 /path/to/jail 为例。这只是办了入狱手续，还要真正的建立监狱才行。chroot 之后，会自动调用 bash，要保证在这个路径下，bash 可以正常使用。只要用 &lt;code&gt;ldd&lt;/code&gt; 解析一下 bash 的依赖，然后将所以依赖放到这个路径下就可以了。监狱制成之后，要自己 &lt;code&gt;chroot&lt;/code&gt;&lt;del&gt; 体验 &lt;/del&gt; 验证一下。&lt;/p&gt;
&lt;h2 id="ssh"&gt;ssh&lt;/h2&gt;
&lt;p&gt;ssh 的问题主要是客户端。linux 和 mac 用户就不用说了，&lt;code&gt;ssh -D&lt;/code&gt; 可以直接参考 manpage，还不会的就去面壁吧。windows 下可以使用 putty，并且 putty 可以事先设置好，直接分发给用户。用户先建立 ssh 连接，再用浏览器 socks 连接到本地绑定的端口。更进一步可以通过安装浏览器插件来根据规则自动地应用 socks，比如 chrome 上可以使用 Proxy Swichy&lt;/p&gt;
&lt;h2 id="pam"&gt;pam&lt;/h2&gt;
&lt;p&gt;pam 有两方面的作用，一个是提供基于用户和地址的登陆验证，一个是限制用户使用系统资源。对于资源限制，主要是防止 fork bomb 和限制登陆数目。这两个都可以在 /etc/security/limits.conf 中完成。其实在 centos6 当中，对于 fork bomb 系统有防范，可以参考 /etc/security/limits.d/，这个值是 1024。另外，对于写的权限控制，最简单的方法是把 jail 建立在 /var 来解决，/var 对非 root:root 的用户是没有写的权限的。对于登陆验证，需要在 sshd_config 中打开 &lt;code&gt;UsePam yes&lt;/code&gt;，并且在 /etc/pam.d/sshd 中加入 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;account    required     pam_nologin.so
account    required     pam_access.so  &lt;span class="c1"&gt;# &amp;lt;- added line&lt;/span&gt;
account    include      password&lt;span class="o"&gt;-&lt;/span&gt;auth
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 此外还要在 /etc/security/access.conf 中写入具体的登陆控制，可以参考其中的 comments，支持用户和 ip 区分。注意这两个文件都是顺序解析的，First Come Firs Serve。所以要注意写入规则的顺序。&lt;/p&gt;
&lt;p&gt; 对于这样建立的 socks 伺服并非没有问题，比如 bandwidth 的限额。&lt;/p&gt;</summary><category term="sshd"></category><category term="pam"></category></entry><entry><title>terminal切换小结</title><link href="http://blog.yuex.in/post/2013/09/terminal-switching.html" rel="alternate"></link><updated>2013-09-24T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:blog.yuex.in,2013-09-24:post/2013/09/terminal-switching.html</id><summary type="html">&lt;p&gt; 早就听说 xterm 和 urxvt 是轻量高可配置，所以想利用周末的时间把某现在在用的 terminator 切换到 xterm 或者 urxvt。结果放弃了。倒不是因为配置太过复杂，而是某觉得，在进行了一定配置之后，对比需求 / 成本 / 收益觉得，这样的配置不能称之为有效。某认为将这些东西总结一下，可能有助于有同样切换初衷的同学少走一些弯路。&lt;/p&gt;
&lt;p&gt; 某切换 terminal 的初始需求 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 可全屏 &lt;/li&gt;
&lt;li&gt; 支持 solarized 的颜色设置 &lt;/li&gt;
&lt;li&gt; 支持 inconsolata-g 和 wenquanyi 中文 &lt;/li&gt;
&lt;li&gt; 支持 tab&lt;/li&gt;
&lt;li&gt; 可以和 tmux 和 powerline 和谐相处 &lt;/li&gt;
&lt;li&gt; 轻量化 &lt;/li&gt;
&lt;li&gt;copy and paste&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 因为 urxvt 的初衷就是取代 xterm。而 terminator，konsole，gnome-terminal，xfce4-terminal 的设置都是大同小异。所以下面的讨论主要以 urxvt 和 terminator 为例。&lt;/p&gt;
&lt;p&gt; 第一条 &lt;/p&gt;
&lt;p&gt;urxvt 需要使用 wmctrl 来进行全屏控制，需要对 urxvt 进行 perl 扩展，可以参考 AUR 中的 urxvt-fullscreen&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。xterm 内建支持 fullscreen，只不过绑定键位是 Alt-Enter&lt;/p&gt;
&lt;p&gt; 第二条 &lt;/p&gt;
&lt;p&gt;urxvt 和 xterm 的颜色设置都是通过 .Xresources 或者 .Xdefaults 来进行的 ( 为个简便，以下仅用 .Xresources 进行指代 )。可以通过 &lt;code&gt;*color&lt;/code&gt; 的通位方式来让 xterm 和 urxvt 来使用相同的位置。但是一旦设置了 foreground color，那么在 vim 当中，就没 reverse video 的效果了。光标不会再根据当前 text 的语法高亮情况来变换光标颜色了 .。&lt;/p&gt;
&lt;p&gt; 第三条 &lt;/p&gt;
&lt;p&gt;urxvt 和 xterm 都可以设置两种字体。不同的是二者在 .Xresources 中的资源名是不同的。urxvt 通过 &lt;code&gt;URxvt.font: xft:*，xft:*&lt;/code&gt; 来指定，而 xterm 要分别使用 &lt;code&gt;xterm.faceName&lt;/code&gt; 和 &lt;code&gt;xterm.faceNameDoubleSize&lt;/code&gt; 来指定英文和中文字体。不过要注意的是，像某这样使用 inconsolata-g 有 &lt;code&gt;-&lt;/code&gt; 符号的，&lt;code&gt;fc-list&lt;/code&gt; 会显示实际的名字要使用 "Inconsolata-g"，这个用法在 &lt;code&gt;urxvt -fn&lt;/code&gt; 的选项中是没有问题的。但如果要将这个配置写入到 .Xresources 当中，要将 &lt;code&gt;\&lt;/code&gt; 再 escape 一次，变成 &lt;code&gt;URxvt.font:xft:Inconsolata\\-g&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 第四条 &lt;/p&gt;
&lt;p&gt;xterm 不支持。urxvt 要通过 perl 扩展。可以参考 tabbed 和 tabbedex&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;。tabbed 是 urxvt 自带的扩展。不同的是 tabbed 只支持新建 tab 和 tab 之间的切换，而 tabbedex 还额外支持 tab 重命名和 tab 位置的相互调换。tabbedex 可以参考 AUR 中的，但是要注意的是 tabbedex 的实现目前有 bug，要手动注释掉其代码中的 &lt;code&gt;on_user_command&lt;/code&gt; 函数，这个并不影响 tabbedex 的功能，只是一个留给用户进行键位绑定的 hook，可以 &lt;code&gt;man urxvtperl&lt;/code&gt; 确认。其实如果是配合 tmux 使用的话，tab 支持可以不考虑，可以用 tmux 的 window 来模拟 tab。&lt;/p&gt;
&lt;p&gt; 第五条 &lt;/p&gt;
&lt;p&gt;xterm 不能显示 powerline 中的 fancy symbol，即使将字体 patch 过也不行。urxvt 可以正常使用 powerline。但二者在配合 tmux 使用时，在使用 manpage 的时候，less 会的 reverse video 有问题，需要做一个 hack&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;。但是做完这个 hack 之后，会使得二者的可移植性大大降低。甚至在 urxvt 中使用 tmux 后，做 &lt;code&gt;sudo&lt;/code&gt; 的时候都会提示，root 下没有做这个 hack，更别说将这些配置直接拷贝到其它机器上了。需要将这个 hack 一同拷贝。&lt;/p&gt;
&lt;p&gt; 第六条 &lt;/p&gt;
&lt;p&gt; 不可否认 xterm 和 urxvt 都是轻量级的 terminal emulator，对系统资源占用较少。某粗略测算 urxvt 是 terminaotr 的 1/5，xterm 是 terminator 的 1/10。但考虑到目前笔电的硬件配置，系统资源占用少已经不能算是一个 killer feature 了。而且就算考虑到系统资源占用，完全可以换装 xfce4-terminal，它的资源使用和 urxvt 和 xterm 完全是可比的。再者说，也没有人会在高负载的 server 上使用图形介面吧 ? 如果还要使用 VNC 来连接 server 的话，这个做法本身就有问题了。&lt;/p&gt;
&lt;p&gt; 第七条 &lt;/p&gt;
&lt;p&gt;xterm 和 urxvt 都需要进行额外的配置。因为做到这一步，某已经决定就到这里了，所以就没有再继续进行这一项的具体配置了。&lt;/p&gt;
&lt;p&gt; 这上面几条来看，虽然 urxvt 和 xterm 可以在经过配置后达到这些目的，但是对应的移植性和维护性都要有所降低，与 terminaotr 这些 terminal 相比，已经不具有即装即用性了。当然，urxvt 也并非全然没有它的特点。比如，在 urxvt 中通过 perl 扩展，可以开启 url 选择模式，完全通过键盘就可以选择 url 并在 browser 中打开。还可以通过 &lt;code&gt;URxvt.colorUL&lt;/code&gt; 来让有下划线的 text 有不同的样式，这个在 manpage 中还是蛮方便的。&lt;/p&gt;
&lt;p&gt; 上所述，某最后决定还是继续使用 terminator 好了。正如一些同学批评的那样 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 有这个时间还不如多写现行代码 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="https://aur.archlinux.org/packages/urxvt-fullscreen/"&gt;https://aur.archlinux.org/packages/urxvt-fullscreen/&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;a href="https://aur.archlinux.org/packages/urxvt-tabbedex-git/"&gt;https://aur.archlinux.org/packages/urxvt-tabbedex-git/&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;&lt;a href="http://tmux.svn.sourceforge.net/viewvc/tmux/trunk/FAQ"&gt;http://tmux.svn.sourceforge.net/viewvc/tmux/trunk/FAQ&lt;/a&gt; search "reverse video"&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="terminal"></category><category term="xterm"></category><category term="urxvt"></category></entry><entry><title>Archlinux环境下pdf注记工具推荐</title><link href="http://blog.yuex.in/post/2013/03/pdf-annotation.html" rel="alternate"></link><updated>2013-03-16T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:blog.yuex.in,2013-03-16:post/2013/03/pdf-annotation.html</id><summary type="html">&lt;p&gt; 从事学术工作的朋友可能像笔者一样，经常会遇到要帮助别人修改文章，或者自己阅读文献要进行批注的情况。由于并不是人人都使用 Linux 和 Latex，所以一般大家会默认地将写好的文章转换为 pdf 格式，然后再进行修改 &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。这样在 Linux 下选择一款得心应手的带有注记功能的 pdf viewer 软件就十分重要了。&lt;/p&gt;
&lt;p&gt; 在 Archlinux 上，有如下几种选择 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Okular          - extra, kde&lt;/li&gt;
&lt;li&gt;evince          - extra, gnome&lt;/li&gt;
&lt;li&gt;masterpdfeditor - aur&lt;/li&gt;
&lt;li&gt;xournal         - extra&lt;/li&gt;
&lt;li&gt;mendeleydesktop - aur&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 不过这些都和 Adobe Acrobat 的用户体验有所差距。有些虽然具有 sticky note 和 highlight 功能，但是 export 之后，在某些 pdf viewer 当中查看存在兼容性问题。几经比较，最后笔者选择了如下的组合 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.tracker-software.com/product/pdf-xchange-viewer"&gt;PDF-XChange Viewer&lt;/a&gt; - needs wine support&lt;/li&gt;
&lt;li&gt;acroread - aur, acrobat reader linux version&lt;/li&gt;
&lt;li&gt;mendeleydesktop&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PDF-Xchange Viewer 需要 wine 的支持，但却比较好的提供了与 acrobat pro 相同的体验，并且生成的注记内容的兼容性非常好。&lt;/p&gt;
&lt;p&gt;acroread 是 acrobat reader 的 linux 版本，可以用来验证 linux 下生成的 pdf 文档在 windows 上打开的效果。&lt;/p&gt;
&lt;p&gt;mendeleydesktop 的注记功能在输出的时候虽然存在兼容性的问题，但用来做个人的文献整理还是非常不错的。&lt;/p&gt;
&lt;p&gt; 另外，以下字体也比较建议安装 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ttf-mac-fonts - aur&lt;/li&gt;
&lt;li&gt;ttf-ms-fonts - aur&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 这两个字体基本提供了 mac 和 microsoft 系统常用的字体，可以保证不会出现字体缺少造成相同文档在不同系统上的字体差异 &lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt; 使用 word 的朋友，一定要先在 windows 上用 word 将 doc 文档转换好 pdf 再发给 Linux 的朋友进行修改。Linux 下虽然也可以对 doc 进行转换，但转换效果并不理想。&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="pdf"></category><category term="archlinux"></category></entry><entry><title>在shell中区分option与args</title><link href="http://blog.yuex.in/post/2013/03/differ-optons-from-args-in-shell.html" rel="alternate"></link><updated>2013-03-02T00:00:00+08:00</updated><author><name>yuex</name></author><id>tag:blog.yuex.in,2013-03-02:post/2013/03/differ-optons-from-args-in-shell.html</id><summary type="html">&lt;p&gt; 使用 &lt;code&gt;--&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 如下，&lt;code&gt;-rf&lt;/code&gt; 会解析为 option，而 &lt;code&gt;--help&lt;/code&gt; 会解析为 args&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;rm -rf -- --help
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;code&gt;man bash&lt;/code&gt; 之后 &lt;code&gt;/--&lt;/code&gt;，可以了解更多信息 &amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="bash"></category></entry></feed>